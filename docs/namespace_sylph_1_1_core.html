<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::Core Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="namespace_sylph_1_1_core.html">Core</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::Core Namespace Reference</h1>The <a class="el" href="namespace_sylph_1_1_core.html" title="The Sylph::Core namespace contains the fundamental classes of LibSylph.">Sylph::Core</a> namespace contains the fundamental classes of LibSylph.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Any</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Application</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ApplicationSelf</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_core_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array.  <a href="class_sylph_1_1_core_1_1_array.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_array_iterator.html">ArrayIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides an <code><a class="el" href="class_sylph_1_1_core_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a></code> for <code><a class="el" href="class_sylph_1_1_core_1_1_array.html" title="Array provides a safe array.">Array</a></code>.  <a href="class_sylph_1_1_core_1_1_array_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ArrayMutableIterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_collection.html">Collection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="class_sylph_1_1_core_1_1_collection.html" title="A Collection represents a group of objects, known as its elements.">Collection</a> represents a group of objects, known as its <em>elements</em>.  <a href="class_sylph_1_1_core_1_1_collection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Dictionary</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>DictionaryIterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_exception.html">Exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides a ready-to-use interface for exception handling.  <a href="class_sylph_1_1_core_1_1_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>File</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hash</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hash&lt; int &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hash&lt; float &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hash&lt; double &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hash&lt; char * &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hash&lt; T * &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hashable</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_iterable.html">Iterable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementing this interface allows your class to be iterated by an <code><a class="el" href="class_sylph_1_1_core_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a></code>.  <a href="class_sylph_1_1_core_1_1_iterable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_iterator.html">Iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_core_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> provides a transparant interface for iterating over collections.  <a href="class_sylph_1_1_core_1_1_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_mutable_iterator.html">MutableIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_core_1_1_mutable_iterator.html" title="MutableIterator provides a transparant interface for iterating over collections.">MutableIterator</a> provides a transparant interface for iterating over collections.  <a href="class_sylph_1_1_core_1_1_mutable_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Library</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_core_1_1_object.html">Object</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root of all classes.  <a href="class_sylph_1_1_core_1_1_object.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Random</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>String</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>UncaughtExceptionHandler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>DefaultUncaughtExceptionHandler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>DebugUncaughtExceptionHandler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>VectorIterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>VectorMutableIterator</b></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>DictionaryIteratorType</b> { <b>KEYS</b>, 
<b>VALUES</b>, 
<b>ENTRIES</b>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph_1_1_core.html#2fd26f88181c404a88ccbf1280418f44">GCPlacement</a> { <a class="el" href="namespace_sylph_1_1_core.html#2fd26f88181c404a88ccbf1280418f4456c79dc968a2daf180476dccdf0e92d0">UseGC</a>, 
<a class="el" href="namespace_sylph_1_1_core.html#2fd26f88181c404a88ccbf1280418f44a7dfaf6c01fc9dbde2c386c8dee58a58">NoGC</a>, 
<a class="el" href="namespace_sylph_1_1_core.html#2fd26f88181c404a88ccbf1280418f44ebb166ab43a56aa7bd9430a807eaab96">PointerFreeGC</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for LibSylph's garbage collection.  <a href="namespace_sylph_1_1_core.html#2fd26f88181c404a88ccbf1280418f44">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="eef820c1f47449338023e49a963e4119"></a><!-- doxytag: member="Sylph::Core::any_cast" ref="eef820c1f47449338023e49a963e4119" args="(Any &amp;any)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>any_cast</b> (Any &amp;any)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph_1_1_core.html#481fb57bde665d785ea390701eccf2e4">operator==</a> (const <a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the two Arrays on equality.  <a href="#481fb57bde665d785ea390701eccf2e4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph_1_1_core.html#e67e4e858fe8845fecf7ebf3c471fd6c">operator&lt;</a> (const <a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the two Arrays.  <a href="#e67e4e858fe8845fecf7ebf3c471fd6c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b62fc22ab31e258c74aaba8ff2f85c70"></a><!-- doxytag: member="Sylph::Core::operator!=" ref="b62fc22ab31e258c74aaba8ff2f85c70" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="eb11fa3adff65ce0c45b85cbad3781eb"></a><!-- doxytag: member="Sylph::Core::operator&gt;" ref="eb11fa3adff65ce0c45b85cbad3781eb" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6d285af59ee3f896fd1480d12a1403f9"></a><!-- doxytag: member="Sylph::Core::operator&lt;=" ref="6d285af59ee3f896fd1480d12a1403f9" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="58ddc2e000074cfe1428f5e13f1220d5"></a><!-- doxytag: member="Sylph::Core::operator&gt;=" ref="58ddc2e000074cfe1428f5e13f1220d5" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="befe3ca4237e84cfb47c482533f98356"></a><!-- doxytag: member="Sylph::Core::operator==" ref="befe3ca4237e84cfb47c482533f98356" args="(const DictionaryPointer &amp;p, const Value &amp;v)" -->
template&lt;class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const DictionaryPointer &amp;p, const Value &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="587fa8a5e3f572dcc85a72fb552e117c"></a><!-- doxytag: member="Sylph::Core::operator!=" ref="587fa8a5e3f572dcc85a72fb552e117c" args="(const DictionaryPointer &amp;p, const Value &amp;v)" -->
template&lt;class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const DictionaryPointer &amp;p, const Value &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7ebdbdfcc33f9c60c61a2e242f31f8f3"></a><!-- doxytag: member="Sylph::Core::Equals" ref="7ebdbdfcc33f9c60c61a2e242f31f8f3" args="(T &amp;t1, T &amp;t2)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Equals</b> (T &amp;t1, T &amp;t2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f72f2cd598e46ef031c90a99ad575d43"></a><!-- doxytag: member="Sylph::Core::Equals" ref="f72f2cd598e46ef031c90a99ad575d43" args="(char *c1, char *c2)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Equals</b> (char *c1, char *c2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="491566b29c316d284fe32f59842c0ea8"></a><!-- doxytag: member="Sylph::Core::Equals" ref="491566b29c316d284fe32f59842c0ea8" args="(T *&amp;t1, T *&amp;t2)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Equals</b> (T *&amp;t1, T *&amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="65ae00945b6f80b5b53f65df2cb91eaa"></a><!-- doxytag: member="Sylph::Core::operator==" ref="65ae00945b6f80b5b53f65df2cb91eaa" args="(const String lhs, const char *rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="931cde0ebb63fcad5c4884d54f3d58e7"></a><!-- doxytag: member="Sylph::Core::operator==" ref="931cde0ebb63fcad5c4884d54f3d58e7" args="(const String lhs, const std::string &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="080a05d0796b375183748b1639bc67a9"></a><!-- doxytag: member="Sylph::Core::operator==" ref="080a05d0796b375183748b1639bc67a9" args="(const String lhs, const String rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8da8da54148b5df160a3e7a7bd2639a0"></a><!-- doxytag: member="Sylph::Core::operator==" ref="8da8da54148b5df160a3e7a7bd2639a0" args="(String lhs, QString rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (String lhs, QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bde7e3485176cb756e9474261516cc3a"></a><!-- doxytag: member="Sylph::Core::operator&lt;" ref="bde7e3485176cb756e9474261516cc3a" args="(String lhs, const char *rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b3500200b195759eaa6a28f93fed1eb"></a><!-- doxytag: member="Sylph::Core::operator&lt;" ref="6b3500200b195759eaa6a28f93fed1eb" args="(String lhs, const std::string &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="63da48d812a397333f25788278f967c9"></a><!-- doxytag: member="Sylph::Core::operator&lt;" ref="63da48d812a397333f25788278f967c9" args="(String lhs, const String rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4431820916cfefb2d5a0cb72509d25c0"></a><!-- doxytag: member="Sylph::Core::operator&lt;" ref="4431820916cfefb2d5a0cb72509d25c0" args="(String lhs, const QString rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (String lhs, const QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5ab3e8dd9bd36d556cde501a207bf9ad"></a><!-- doxytag: member="Sylph::Core::operator+=" ref="5ab3e8dd9bd36d556cde501a207bf9ad" args="(const String lhs, const char *rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0cc161fd4aa606d956934c1b3d9e7cfe"></a><!-- doxytag: member="Sylph::Core::operator+=" ref="0cc161fd4aa606d956934c1b3d9e7cfe" args="(const String lhs, const std::string &amp;rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2282224afcc0717db28f99ea8a942665"></a><!-- doxytag: member="Sylph::Core::operator+=" ref="2282224afcc0717db28f99ea8a942665" args="(const String lhs, const String rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9b72872b30cf33201c3f31626f5a8648"></a><!-- doxytag: member="Sylph::Core::operator+=" ref="9b72872b30cf33201c3f31626f5a8648" args="(const String lhs, const QString rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="03c673e216110e1512619186203da6de"></a><!-- doxytag: member="Sylph::Core::operator+" ref="03c673e216110e1512619186203da6de" args="(const String lhs, const char *rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="63a24702384e46cf6dd17bf38203e4fe"></a><!-- doxytag: member="Sylph::Core::operator+" ref="63a24702384e46cf6dd17bf38203e4fe" args="(const String lhs, const std::string &amp;rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df45e427df63b970f1dd00798cd921c2"></a><!-- doxytag: member="Sylph::Core::operator+" ref="df45e427df63b970f1dd00798cd921c2" args="(const String lhs, const String rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d037ca509312a1a9944457ec2e61213"></a><!-- doxytag: member="Sylph::Core::operator+" ref="4d037ca509312a1a9944457ec2e61213" args="(const String lhs, const QString rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const QString rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="85f8551e980a849f38128a0cfb832e8f"></a><!-- doxytag: member="Sylph::Core::carraycopy" ref="85f8551e980a849f38128a0cfb832e8f" args="(T src[], std::size_t srcPos, T dest[], std::size_t destPos, std::size_t length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>carraycopy</b> (T src[], std::size_t srcPos, T dest[], std::size_t destPos, std::size_t length)  throw (Exception)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0ce40c2135667aac7545629cb2f661de"></a><!-- doxytag: member="Sylph::Core::arraycopy" ref="0ce40c2135667aac7545629cb2f661de" args="(Array&lt; T &gt; &amp;src, std::size_t srcPos, Array&lt; T &gt; dest, std::size_t destPos, std::size_t length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>arraycopy</b> (<a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;src, std::size_t srcPos, <a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; dest, std::size_t destPos, std::size_t length)  throw (Exception)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="17ccc7c01ec9ff586ab3acfcac928f94"></a><!-- doxytag: member="Sylph::Core::carraysize" ref="17ccc7c01ec9ff586ab3acfcac928f94" args="(T array[])" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>carraysize</b> (T array[])</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="802eff84c2729864d24af65f8be58b05"></a><!-- doxytag: member="Sylph::Core::arraycopy" ref="802eff84c2729864d24af65f8be58b05" args="(Array&lt; T &gt; &amp;src, std::size_t srcPos, Array&lt; T &gt; &amp;dest, std::size_t destPos, std::size_t length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>arraycopy</b> (<a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;src, std::size_t srcPos, <a class="el" href="class_sylph_1_1_core_1_1_array.html">Array</a>&lt; T &gt; &amp;dest, std::size_t destPos, std::size_t length)  throw (Exception)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="namespace_sylph_1_1_core.html" title="The Sylph::Core namespace contains the fundamental classes of LibSylph.">Sylph::Core</a> namespace contains the fundamental classes of LibSylph. 
<p>
Examples are Application, <a class="el" href="class_sylph_1_1_core_1_1_object.html" title="The root of all classes.">Object</a>, String, Vector, .... <p>
<dl class="user" compact><dt><b>Dependencies:</b></dt><dd><a class="el" href="namespace_sylph_1_1_o_s.html" title="The Sylph::OS namespace contains all portability modules.">Sylph::OS</a> </dd></dl>
<dl class="user" compact><dt><b>Cross-platform?</b></dt><dd>Most classes are cross-platform, but <a class="el" href="class_sylph_1_1_core_1_1_array.html" title="Array provides a safe array.">Array</a> currently depends on C++0x initializer_lists.  </dd></dl>

<p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="2fd26f88181c404a88ccbf1280418f44"></a><!-- doxytag: member="Sylph::Core::GCPlacement" ref="2fd26f88181c404a88ccbf1280418f44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_sylph_1_1_core.html#2fd26f88181c404a88ccbf1280418f44">Sylph::Core::GCPlacement</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used for LibSylph's garbage collection. 
<p>
It is passed as a parameter to new, e.g. <pre>
 Array&lt;int&gt;; = new (NoGC) Array&lt;int&gt;(5); // create a length-5 array without GC
 </pre> This is most often used for creating LibSylph-objects not managed by the garbage collector. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="2fd26f88181c404a88ccbf1280418f4456c79dc968a2daf180476dccdf0e92d0"></a><!-- doxytag: member="UseGC" ref="2fd26f88181c404a88ccbf1280418f4456c79dc968a2daf180476dccdf0e92d0" args="" -->UseGC</em>&nbsp;</td><td>
Use the garbage collector; this is the default. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2fd26f88181c404a88ccbf1280418f44a7dfaf6c01fc9dbde2c386c8dee58a58"></a><!-- doxytag: member="NoGC" ref="2fd26f88181c404a88ccbf1280418f44a7dfaf6c01fc9dbde2c386c8dee58a58" args="" -->NoGC</em>&nbsp;</td><td>
Do not use the garbage collector for this specific object. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2fd26f88181c404a88ccbf1280418f44ebb166ab43a56aa7bd9430a807eaab96"></a><!-- doxytag: member="PointerFreeGC" ref="2fd26f88181c404a88ccbf1280418f44ebb166ab43a56aa7bd9430a807eaab96" args="" -->PointerFreeGC</em>&nbsp;</td><td>
When the object you create does not contain pointers, use this to speed up GC -- however, this is usually not useful, as most LibSylph containers contain pointers. 
<p>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="e67e4e858fe8845fecf7ebf3c471fd6c"></a><!-- doxytag: member="Sylph::Core::operator&lt;" ref="e67e4e858fe8845fecf7ebf3c471fd6c" args="(const Array&lt; T &gt; &amp;lhs, const Array&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sylph::Core::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the two Arrays. 
<p>
To Arrays compare less than when their lengths are identical and each of the items compare less than to the item on the same position in the other array. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> when the first array compares less than the first, <em>false</em> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="481fb57bde665d785ea390701eccf2e4"></a><!-- doxytag: member="Sylph::Core::operator==" ref="481fb57bde665d785ea390701eccf2e4" args="(const Array&lt; T &gt; &amp;lhs, const Array&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sylph::Core::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the two Arrays on equality. 
<p>
To Arrays compare equal when their lengths are identical and each of the items compare equal to the item on the same position in the other array. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> when the two arrays compare equal, <em>false</em> otherwise. </dd></dl>

</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
