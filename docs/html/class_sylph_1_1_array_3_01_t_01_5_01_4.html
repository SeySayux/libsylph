<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::Array&lt; T * &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html">Array&lt; T * &gt;</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::Array&lt; T * &gt; Class Template Reference</h1><!-- doxytag: class="Sylph::Array&lt; T * &gt;" --><!-- doxytag: inherits="Array_base&lt; T &gt;" -->Specialisation of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class for pointers.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_array_8h-source.html">Sylph/Core/Array.h</a>&gt;</code>
<p>
Inherits <a class="el" href="class_sylph_1_1_array__base.html">Array_base&lt; T &gt;</a>.
<p>
<div class="dynheader">
Collaboration diagram for Sylph::Array&lt; T * &gt;:</div>
<div class="dynsection">
<p><center><img src="class_sylph_1_1_array_3_01_t_01_5_01_4__coll__graph.png" border="0" usemap="#_sylph_1_1_array_3_01_t_01_5_01_4__coll__map" alt="Collaboration graph"></center>
<map name="_sylph_1_1_array_3_01_t_01_5_01_4__coll__map">
<area shape="rect" href="class_sylph_1_1_array__base.html" title="Sylph::Array_base\&lt; T \&gt;" alt="" coords="8,85,226,111"><area shape="rect" href="class_sylph_1_1_object.html" title="The root of all classes." alt="" coords="52,7,182,34"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_sylph_1_1_array_3_01_t_01_5_01_4-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html#c1d0669d07c6a76b530b62a052243d57">Array</a> (std::size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the specified length.  <a href="#c1d0669d07c6a76b530b62a052243d57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html#bc860875f0bb4b4b6d562bef6bc4e171">Array</a> (const std::initializer_list&lt; T &gt; &amp;il)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an intializer list.  <a href="#bc860875f0bb4b4b6d562bef6bc4e171"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html#483c473ba6ee83e79caf17315d2fc9d7">Array</a> (const T *array[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an existing C-style array.  <a href="#483c473ba6ee83e79caf17315d2fc9d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html#ea807d27d6b0e3f5c43bb273cf098d34">Array</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T * &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from another instance of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class.  <a href="#ea807d27d6b0e3f5c43bb273cf098d34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html#e536f87789440760dbb243625032c8e1">Array</a> (const T *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from a single pointer.  <a href="#e536f87789440760dbb243625032c8e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html#74d49cf136d9f2b58492e9e39ad16bba">~Array</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#74d49cf136d9f2b58492e9e39ad16bba"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class Sylph::Array&lt; T * &gt;</h3>

Specialisation of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class for pointers. 
<p>
This class allows easier use of arrays-of-pointers, as it is overloaded to take ownership of the pointers. This makes creation (and deletion) of arrays-of-pointers easier, as no explicit deletion of an Array's contents is required. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c1d0669d07c6a76b530b62a052243d57"></a><!-- doxytag: member="Sylph::Array&lt; T * &gt;::Array" ref="c1d0669d07c6a76b530b62a052243d57" args="(std::size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T * &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the specified length. 
<p>
A new instance of the reference counted data is created, its reference count set to 1 and the internal C array is allocated to have the specified length. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the new <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc860875f0bb4b4b6d562bef6bc4e171"></a><!-- doxytag: member="Sylph::Array&lt; T * &gt;::Array" ref="bc860875f0bb4b4b6d562bef6bc4e171" args="(const std::initializer_list&lt; T &gt; &amp;il)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T * &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>il</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an intializer list. 
<p>
This constructor allows the easier, more familiar syntax of <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> creation, but requires C++0x. Using this constructor, arrays can be initialized as following: <pre>Array&lt;int&gt; myarr = {5,4,7,9};</pre> A new instance of the reference counted data is created, the reference count is set to 1, the length is set to the length of the intializer list, and all data is copied into a newly allocated C array. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>il</em>&nbsp;</td><td>The initializer_list used to create the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="483c473ba6ee83e79caf17315d2fc9d7"></a><!-- doxytag: member="Sylph::Array&lt; T * &gt;::Array" ref="483c473ba6ee83e79caf17315d2fc9d7" args="(const T *array[])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T * &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>array</em>[]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an existing C-style array. 
<p>
Note that you can only pass a true array, i.e. you cannot pass a pointer that acts as an array. If you only have a pointer, you'll have to initialize using Array::fromPointer(size_t, length) . <p>
A new instance of the reference counted data is created, the reference count is set to 1, the length is set to the length of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, all data is copied into a newly allocated C array with the same length as the original array. The original array remains unmodified.<p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> will assume ownership over any pointers in the original <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>A traditional, C-style array to create this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ea807d27d6b0e3f5c43bb273cf098d34"></a><!-- doxytag: member="Sylph::Array&lt; T * &gt;::Array" ref="ea807d27d6b0e3f5c43bb273cf098d34" args="(const Array&lt; T * &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T * &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from another instance of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class. 
<p>
The data is not copied, instead, the pointer to the refernce counted data will be set to the reference counted data of the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, and the reference count will increase by 1. Other fields of the reference counted data remain unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>An other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from which to use the reference counted data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e536f87789440760dbb243625032c8e1"></a><!-- doxytag: member="Sylph::Array&lt; T * &gt;::Array" ref="e536f87789440760dbb243625032c8e1" args="(const T *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T * &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from a single pointer. 
<p>
This is useful for implicit conversions, as it allows a single pointer to a class to be passed as an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> of pointers to class with length 1. <p>
A new instance of the reference counted data is created, the reference count set to 1, the length is set to 1, and a new C-style array with length 1 is allocated. The pointer is copied into this array, the original pointer remains unmodified.<p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> will assume ownership over this pointer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>An object to create a length-1 array from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="74d49cf136d9f2b58492e9e39ad16bba"></a><!-- doxytag: member="Sylph::Array&lt; T * &gt;::~Array" ref="74d49cf136d9f2b58492e9e39ad16bba" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T * &gt;::~<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Reduces the reference count by 1. If the reference count reaches zero, the internal backing data will be deleted. All pointers in the backing array will be deleted as well. 
</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
