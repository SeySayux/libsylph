<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::Array&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="class_sylph_1_1_array.html">Array</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::Array&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="Sylph::Array" --><!-- doxytag: inherits="Sylph::Object" --><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_array_8h-source.html">/Users/frank/Dropbox/sylph/src/Sylph/Core/Array.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Sylph::Array&lt; T &gt;:</div>
<div class="dynsection">
<p><center><img src="class_sylph_1_1_array__inherit__graph.png" border="0" usemap="#_sylph_1_1_array_3_01_t_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="_sylph_1_1_array_3_01_t_01_4__inherit__map">
<area shape="rect" id="node2" href="class_sylph_1_1_object.html" title="The root of all classes." alt="" coords="19,5,131,35"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_sylph_1_1_array-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_1_1iterator.html">iterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#e4405625c4cc5923e0b8fc8fb437a001">FilterFunction</a> )(const T &amp;, <a class="el" href="class_sylph_1_1_any.html">Any</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function that is used for filtering by the <a class="el" href="class_sylph_1_1_array.html#b46e1eff76bf8750176a840022d85393" title="This will filter the Array according to a FilterFunction.">filter()</a> method.  <a href="#e4405625c4cc5923e0b8fc8fb437a001"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#d1066e241cbe5ab5531267b786f29c57">Array</a> (std::size_t len=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the specified length.  <a href="#d1066e241cbe5ab5531267b786f29c57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#dbbad8c487665fd8b4b56a8677d7bca8">Array</a> (const std::initializer_list&lt; T &gt; &amp;il)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an intializer list.  <a href="#dbbad8c487665fd8b4b56a8677d7bca8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#647dc899b23b352d5fac47883028af0f">Array</a> (const T(&amp;array)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an existing C-style array.  <a href="#647dc899b23b352d5fac47883028af0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#928ad30994a7f3cd7a9c26bfde51689d">Array</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from another instance of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class.  <a href="#928ad30994a7f3cd7a9c26bfde51689d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#6272731c791b129188873fd669a2ac93">Array</a> (const basic_range&lt; T &gt; &amp;ran)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an array from a range of items.  <a href="#6272731c791b129188873fd669a2ac93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#3d4530aa8417cbf35b7d67d75abb15a6">Array</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from a single item.  <a href="#3d4530aa8417cbf35b7d67d75abb15a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#d4a67621f6f91387f75e50e9ef975bf7">~Array</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#d4a67621f6f91387f75e50e9ef975bf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#ee7eb7bc5e19aef28d7d58a58a0e7abe">copy</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this array.  <a href="#ee7eb7bc5e19aef28d7d58a58a0e7abe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#6f4b7a642f0548cd0c6097b54296e14d">carray</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="#6f4b7a642f0548cd0c6097b54296e14d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#7710b1d662712fbdf10b7998b2040cd4">carray</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="#7710b1d662712fbdf10b7998b2040cd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#b46e1eff76bf8750176a840022d85393">filter</a> (<a class="el" href="class_sylph_1_1_array.html#e4405625c4cc5923e0b8fc8fb437a001">FilterFunction</a> func, <a class="el" href="class_sylph_1_1_any.html">Any</a> &amp;clientData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will filter the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> according to a FilterFunction.  <a href="#b46e1eff76bf8750176a840022d85393"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e62754e1628aed49d7f514803296ae4b"></a><!-- doxytag: member="Sylph::Array::clear" ref="e62754e1628aed49d7f514803296ae4b" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#e62754e1628aed49d7f514803296ae4b">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets every entry in the array to the object returned by that classes' default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#c3e4f7e2ac9074863b6b94856bd79622">operator=</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the data pointer of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="#c3e4f7e2ac9074863b6b94856bd79622"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#9976e4486a5e539fc04b39756e67c71e">operator[]</a> (std::sidx_t idx)  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for accessing the Array's contents.  <a href="#9976e4486a5e539fc04b39756e67c71e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#563bf3a6b4239d551df7bdb6df48a640">operator[]</a> (std::sidx_t idx) const   throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the <code>const</code> version of T&amp; operator[] .  <a href="#563bf3a6b4239d551df7bdb6df48a640"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#c621cb5748d4fef484a83b91a6e72ece">operator[]</a> (const range &amp;ran)  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slices the array and returns the subarray.  <a href="#c621cb5748d4fef484a83b91a6e72ece"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#a1221040e56ad8a7ed7e0e4d6af61ea2">operator[]</a> (const range &amp;ran) const   throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const-version of <a class="el" href="class_sylph_1_1_array.html#c621cb5748d4fef484a83b91a6e72ece" title="Slices the array and returns the subarray.">operator[](const range &amp;)</a> .  <a href="#a1221040e56ad8a7ed7e0e4d6af61ea2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#71636c733d300bf785b95338ebf317ec">fromPointer</a> (std::size_t <a class="el" href="class_sylph_1_1_array.html#b804d99eeea5dd079706490062f196f2">length</a>, T *orig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an Array&lt;T&gt; from a pointer to T and a length.  <a href="#71636c733d300bf785b95338ebf317ec"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const size_t &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#b804d99eeea5dd079706490062f196f2">length</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The length of the array.  <a href="#b804d99eeea5dd079706490062f196f2"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class Sylph::Array&lt; T &gt;</h3>

<a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array. 
<p>
It works the same like a c-style array (not like std::vector which can expand), but instead of overflowing, it throws an <code><a class="el" href="class_sylph_1_1_exception.html" title="This class provides a ready-to-use interface for exception handling.">Exception</a></code> whenever you try to access data outside its bounds. Therefore it also keeps track of its own length. <p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class provided here is reference-counted, which means it's perfectly safe and even recommended to pass it by value instead of by reference or by pointer. This way, the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> acts more like a builtin type and does not obstruct the workflow. <p>
Please note that most constructors copy the contents into the array, which means that unless the type used is easy to copy, using the specialized array-to-pointer ( Array&lt;T*&gt; ) is preferred. <dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>T</em> CopyConstructible, DefaultConstructible, Assignable </dd></dl>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="e4405625c4cc5923e0b8fc8fb437a001"></a><!-- doxytag: member="Sylph::Array::FilterFunction" ref="e4405625c4cc5923e0b8fc8fb437a001" args=")(const T &amp;, Any &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html#e4405625c4cc5923e0b8fc8fb437a001">FilterFunction</a>)(const T &amp;, <a class="el" href="class_sylph_1_1_any.html">Any</a> &amp;)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function that is used for filtering by the <a class="el" href="class_sylph_1_1_array.html#b46e1eff76bf8750176a840022d85393" title="This will filter the Array according to a FilterFunction.">filter()</a> method. 
<p>
This function takes both an instance of the class this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> contains, and a reference to a reference to any kind of other data that may need to be passed to the FilterFunction. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d1066e241cbe5ab5531267b786f29c57"></a><!-- doxytag: member="Sylph::Array::Array" ref="d1066e241cbe5ab5531267b786f29c57" args="(std::size_t len=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the specified length. 
<p>
A new instance of the reference counted data is created, its reference count set to 1 and the internal C array is allocated to have the specified length. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the new <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dbbad8c487665fd8b4b56a8677d7bca8"></a><!-- doxytag: member="Sylph::Array::Array" ref="dbbad8c487665fd8b4b56a8677d7bca8" args="(const std::initializer_list&lt; T &gt; &amp;il)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>il</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an intializer list. 
<p>
This constructor allows the easier, more familiar syntax of <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> creation, but requires C++0x. Using this constructor, arrays can be initialized as following: <pre>Array&lt;int&gt; myarr = {5,4,7,9};</pre> A new instance of the reference counted data is created, the reference count is set to 1, the length is set to the length of the intializer list, and all data is copied into a newly allocated C array. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>il</em>&nbsp;</td><td>The initializer_list used to create the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="647dc899b23b352d5fac47883028af0f"></a><!-- doxytag: member="Sylph::Array::Array" ref="647dc899b23b352d5fac47883028af0f" args="(const T(&amp;array)[N])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&nbsp;</td>
          <td class="paramname"> <em>array</em>[N]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an existing C-style array. 
<p>
Note that you can only pass a true array, i.e. you cannot pass a pointer that acts as an array. If you only have a pointer, you'll have to initialize using Array::fromPointer(size_t, length) . <p>
A new instance of the reference counted data is created, the reference count is set to 1, the length is set to the length of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, all data is copied into a newly allocated C array with the same length as the original array. The original array remains unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>A traditional, C-style array to create this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="928ad30994a7f3cd7a9c26bfde51689d"></a><!-- doxytag: member="Sylph::Array::Array" ref="928ad30994a7f3cd7a9c26bfde51689d" args="(const Array&lt; T &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from another instance of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class. 
<p>
The data is not copied, instead, the pointer to the refernce counted data will be set to the reference counted data of the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, and the reference count will increase by 1. Other fields of the reference counted data remain unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>An other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from which to use the reference counted data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6272731c791b129188873fd669a2ac93"></a><!-- doxytag: member="Sylph::Array::Array" ref="6272731c791b129188873fd669a2ac93" args="(const basic_range&lt; T &gt; &amp;ran)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const basic_range&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an array from a range of items. 
<p>
Every item within the range will be added to the array. This is most useful for integral types, as other types usually don't support the required semantics.<p>
A new instance of the reference counted data is created, the reference count is set to 1, the length is set to <code>ran.last() - ran.first() </code>, a new C-style array with this length will be allocated. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>a range class that specifies the lower and upper boundaries. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>T</em> operator++, LessThanComparable </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d4530aa8417cbf35b7d67d75abb15a6"></a><!-- doxytag: member="Sylph::Array::Array" ref="3d4530aa8417cbf35b7d67d75abb15a6" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from a single item. 
<p>
This is useful for implicit conversions, as it allows a single instance of a class to be passed as an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> of that class with length 1. <p>
A new instance of the reference counted data is created, the reference count set to 1, the length is set to 1, and a new C-style array with length 1 is allocated. The object is copied into this array, the original object remains unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>An object to create a length-1 array from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d4a67621f6f91387f75e50e9ef975bf7"></a><!-- doxytag: member="Sylph::Array::~Array" ref="d4a67621f6f91387f75e50e9ef975bf7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::~<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Reduces the reference count by 1. If the reference count reaches 0, the internal backing data will be destroyed. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7710b1d662712fbdf10b7998b2040cd4"></a><!-- doxytag: member="Sylph::Array::carray" ref="7710b1d662712fbdf10b7998b2040cd4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::carray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
The array returned is not a copy of this array, in fact, changes to the returned array are reflected in this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. This version returns a const c-style array and is used when this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> is const. 
</div>
</div><p>
<a class="anchor" name="6f4b7a642f0548cd0c6097b54296e14d"></a><!-- doxytag: member="Sylph::Array::carray" ref="6f4b7a642f0548cd0c6097b54296e14d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::carray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
The array returned is not a copy of this array, in fact, changes to the returned array are reflected in this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
</div>
</div><p>
<a class="anchor" name="ee7eb7bc5e19aef28d7d58a58a0e7abe"></a><!-- doxytag: member="Sylph::Array::copy" ref="ee7eb7bc5e19aef28d7d58a58a0e7abe" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a copy of this array. 
<p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> returned from this method is an exact copy of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, such that ar == ar.copy() . The returned <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> is different from the one returned by operator=, as the reference counted data gets copied as well, in other words, both Arrays will have a different, equal instance of the reference counted data. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> containing the same data as this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b46e1eff76bf8750176a840022d85393"></a><!-- doxytag: member="Sylph::Array::filter" ref="b46e1eff76bf8750176a840022d85393" args="(FilterFunction func, Any &amp;clientData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sylph_1_1_array.html#e4405625c4cc5923e0b8fc8fb437a001">FilterFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sylph_1_1_any.html">Any</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clientData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This will filter the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> according to a FilterFunction. 
<p>
This function returns a new, 'filtered' <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, which only contains the entries for which the FilterFunction returns true. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>A pointer to the function which is used for filtering </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientData</em>&nbsp;</td><td>Any data to be passed to the FilterFunction </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new array containing only the filtered data </dd></dl>

</div>
</div><p>
<a class="anchor" name="71636c733d300bf785b95338ebf317ec"></a><!-- doxytag: member="Sylph::Array::fromPointer" ref="71636c733d300bf785b95338ebf317ec" args="(std::size_t length, T *orig)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::fromPointer           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>orig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an Array&lt;T&gt; from a pointer to T and a length. 
<p>
The new array will have the length specified in <code>length</code>. The original array will not be modified, the contents are copied. No bounds-checking is done, therefore, use this function at your own responsability! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the original C array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The original C array, supplied as a pointer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c3e4f7e2ac9074863b6b94856bd79622"></a><!-- doxytag: member="Sylph::Array::operator=" ref="c3e4f7e2ac9074863b6b94856bd79622" args="(const Array&lt; T &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the data pointer of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
The refcount for the current data pointer gets decreased by 1, the refcount for the data pointer of the other array gets increased by 1. In case the this Array'soriginal data pointer's refcount reaches zero, the original data will be deleted. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The other array from which to use the data pointer </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1221040e56ad8a7ed7e0e4d6af61ea2"></a><!-- doxytag: member="Sylph::Array::operator[]" ref="a1221040e56ad8a7ed7e0e4d6af61ea2" args="(const range &amp;ran) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const range &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Const-version of <a class="el" href="class_sylph_1_1_array.html#c621cb5748d4fef484a83b91a6e72ece" title="Slices the array and returns the subarray.">operator[](const range &amp;)</a> . 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>The range describing the slice </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if ran.last() &gt; length </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c621cb5748d4fef484a83b91a6e72ece"></a><!-- doxytag: member="Sylph::Array::operator[]" ref="c621cb5748d4fef484a83b91a6e72ece" args="(const range &amp;ran)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const range &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Slices the array and returns the subarray. 
<p>
E.g. : <pre>Array&lt;String&gt; subarr = myarr[range(5,8)]</pre> <code>subarr</code> now contains the values of <code>myarr</code>[5] to <code>myarr</code>[8] . Please note that the subarray contains a copy of the original. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>The range describing the slice. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if ran.last() &gt; length </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="563bf3a6b4239d551df7bdb6df48a640"></a><!-- doxytag: member="Sylph::Array::operator[]" ref="563bf3a6b4239d551df7bdb6df48a640" args="(std::sidx_t idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">std::sidx_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the <code>const</code> version of T&amp; operator[] . 
<p>
Its behaviour is identical to that of c-style const arrays, but throws an exception instead of overflowing or causing segfaults. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>the index in the array from which to return an element </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if <code>idx &gt; length</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9976e4486a5e539fc04b39756e67c71e"></a><!-- doxytag: member="Sylph::Array::operator[]" ref="9976e4486a5e539fc04b39756e67c71e" args="(std::sidx_t idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">std::sidx_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used for accessing the Array's contents. 
<p>
Its behaviour is identical to that of c-style arrays, but throws an exception instead of overflowing or causing segfaults. <p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> will assume ownership over any pointers entered in this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>the index in the array from which to return an element </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if <code>idx &gt; length</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="b804d99eeea5dd079706490062f196f2"></a><!-- doxytag: member="Sylph::Array::length" ref="b804d99eeea5dd079706490062f196f2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const size_t&amp; <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html#b804d99eeea5dd079706490062f196f2">length</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The length of the array. 
<p>
This variable is 1-based, while the array itself is 0-based, i.e. if length == N the highest entry in this array is N-1. E.g if array.length == 5, then the higest entry is array[4] 
</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph by Doxygen
</body>
</html>
