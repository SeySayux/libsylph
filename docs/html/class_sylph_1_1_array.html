<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::Array&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="class_sylph_1_1_array.html">Array</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::Array&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="Sylph::Array" --><!-- doxytag: inherits="Array_base&lt; T &gt;" --><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_array_8h-source.html">Sylph/Core/Array.h</a>&gt;</code>
<p>
Inherits <a class="el" href="class_sylph_1_1_array__base.html">Array_base&lt; T &gt;</a>.
<p>
<div class="dynheader">
Collaboration diagram for Sylph::Array&lt; T &gt;:</div>
<div class="dynsection">
<p><center><img src="class_sylph_1_1_array__coll__graph.png" border="0" usemap="#_sylph_1_1_array_3_01_t_01_4__coll__map" alt="Collaboration graph"></center>
<map name="_sylph_1_1_array_3_01_t_01_4__coll__map">
<area shape="rect" href="class_sylph_1_1_array__base.html" title="Sylph::Array_base\&lt; T \&gt;" alt="" coords="8,85,226,111"><area shape="rect" href="class_sylph_1_1_object.html" title="The root of all classes." alt="" coords="52,7,182,34"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_sylph_1_1_array-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#d1641b1a577699a84a47c08ce0f99e21">Array</a> (std::size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the specified length.  <a href="#d1641b1a577699a84a47c08ce0f99e21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#dbbad8c487665fd8b4b56a8677d7bca8">Array</a> (const std::initializer_list&lt; T &gt; &amp;il)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an intializer list.  <a href="#dbbad8c487665fd8b4b56a8677d7bca8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#8582a8da877dc5bb57baa2dfe1e88258">Array</a> (const T array[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an existing C-style array.  <a href="#8582a8da877dc5bb57baa2dfe1e88258"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#928ad30994a7f3cd7a9c26bfde51689d">Array</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from another instance of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class.  <a href="#928ad30994a7f3cd7a9c26bfde51689d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#6272731c791b129188873fd669a2ac93">Array</a> (const basic_range&lt; T &gt; &amp;ran)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an array from a range of items.  <a href="#6272731c791b129188873fd669a2ac93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#3d4530aa8417cbf35b7d67d75abb15a6">Array</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from a single item.  <a href="#3d4530aa8417cbf35b7d67d75abb15a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html#d4a67621f6f91387f75e50e9ef975bf7">~Array</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#d4a67621f6f91387f75e50e9ef975bf7"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class Sylph::Array&lt; T &gt;</h3>

<a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array. 
<p>
It works the same like a c-style array (not like std::vector which can expand), but instead of overflowing, it throws an <code><a class="el" href="class_sylph_1_1_exception.html" title="This class provides a ready-to-use interface for exception handling.">Exception</a></code> whenever you try to access data outside its bounds. Therefore it also keeps track of its own length. <p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class provided here is reference-counted, which means it's perfectly safe and even recommended to pass it by value instead of by reference or by pointer. This way, the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> acts more like a builtin type and does not obstruct the workflow. <p>
Please note that most constructors copy the contents into the array, which means that unless the type used is easy to copy, using the specialized array-to-pointer ( <a class="el" href="class_sylph_1_1_array_3_01_t_01_5_01_4.html" title="Specialisation of the Array class for pointers.">Array&lt;T*&gt;</a> ) is prefered. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d1641b1a577699a84a47c08ce0f99e21"></a><!-- doxytag: member="Sylph::Array::Array" ref="d1641b1a577699a84a47c08ce0f99e21" args="(std::size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the specified length. 
<p>
A new instance of the reference counted data is created, its reference count set to 1 and the internal C array is allocated to have the specified length. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>The length of the new <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dbbad8c487665fd8b4b56a8677d7bca8"></a><!-- doxytag: member="Sylph::Array::Array" ref="dbbad8c487665fd8b4b56a8677d7bca8" args="(const std::initializer_list&lt; T &gt; &amp;il)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>il</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an intializer list. 
<p>
This constructor allows the easier, more familiar syntax of <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> creation, but requires C++0x. Using this constructor, arrays can be initialized as following: <pre>Array&lt;int&gt; myarr = {5,4,7,9};</pre> A new instance of the reference counted data is created, the reference count is set to 1, the length is set to the length of the intializer list, and all data is copied into a newly allocated C array. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>il</em>&nbsp;</td><td>The initializer_list used to create the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8582a8da877dc5bb57baa2dfe1e88258"></a><!-- doxytag: member="Sylph::Array::Array" ref="8582a8da877dc5bb57baa2dfe1e88258" args="(const T array[])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>array</em>[]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from an existing C-style array. 
<p>
Note that you can only pass a true array, i.e. you cannot pass a pointer that acts as an array. If you only have a pointer, you'll have to initialize using Array::fromPointer(size_t, length) . <p>
A new instance of the reference counted data is created, the reference count is set to 1, the length is set to the length of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, all data is copied into a newly allocated C array with the same length as the original array. The original array remains unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>A traditional, C-style array to create this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="928ad30994a7f3cd7a9c26bfde51689d"></a><!-- doxytag: member="Sylph::Array::Array" ref="928ad30994a7f3cd7a9c26bfde51689d" args="(const Array&lt; T &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from another instance of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> class. 
<p>
The data is not copied, instead, the pointer to the refernce counted data will be set to the reference counted data of the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, and the reference count will increase by 1. Other fields of the reference counted data remain unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>An other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from which to use the reference counted data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6272731c791b129188873fd669a2ac93"></a><!-- doxytag: member="Sylph::Array::Array" ref="6272731c791b129188873fd669a2ac93" args="(const basic_range&lt; T &gt; &amp;ran)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const basic_range&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an array from a range of items. 
<p>
Every item within the range will be added to the array. This is most useful for integral types, as other types usually don't support the required semantics.<p>
A new instance of the reference counted data is created, the reference count is set to 1, the length is set to <code>ran.last() - ran.first() </code>, a new C-style array with this length will be allocated. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>a range class that specifies the lower and upper boundaries. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3d4530aa8417cbf35b7d67d75abb15a6"></a><!-- doxytag: member="Sylph::Array::Array" ref="3d4530aa8417cbf35b7d67d75abb15a6" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> from a single item. 
<p>
This is useful for implicit conversions, as it allows a single instance of a class to be passed as an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> of that class with length 1. <p>
A new instance of the reference counted data is created, the reference count set to 1, the length is set to 1, and a new C-style array with length 1 is allocated. The object is copied into this array, the original object remains unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>An object to create a length-1 array from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d4a67621f6f91387f75e50e9ef975bf7"></a><!-- doxytag: member="Sylph::Array::~Array" ref="d4a67621f6f91387f75e50e9ef975bf7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sylph_1_1_array.html">Sylph::Array</a>&lt; T &gt;::~<a class="el" href="class_sylph_1_1_array.html">Array</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Reduces the reference count by 1. If the reference count reaches 0, the internal backing data will be destroyed. 
</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
