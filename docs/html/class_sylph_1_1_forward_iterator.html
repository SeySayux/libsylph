<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::ForwardIterator&lt; T, IteratedObject &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="class_sylph_1_1_forward_iterator.html">ForwardIterator</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::ForwardIterator&lt; T, IteratedObject &gt; Class Template Reference</h1><!-- doxytag: class="Sylph::ForwardIterator" --><!-- doxytag: inherits="Sylph::Object" -->Facade used to simplify usage of forward iterators.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_iterator_8h-source.html">Sylph/Core/Iterator.h</a>&gt;</code>
<p>
Inherits <a class="el" href="class_sylph_1_1_object.html">Sylph::Object</a>.
<p>
<div class="dynheader">
Collaboration diagram for Sylph::ForwardIterator&lt; T, IteratedObject &gt;:</div>
<div class="dynsection">
<p><center><img src="class_sylph_1_1_forward_iterator__coll__graph.png" border="0" usemap="#_sylph_1_1_forward_iterator_3_01_t_00_01_iterated_object_01_4__coll__map" alt="Collaboration graph"></center>
<map name="_sylph_1_1_forward_iterator_3_01_t_00_01_iterated_object_01_4__coll__map">
<area shape="rect" href="class_sylph_1_1_object.html" title="The root of all classes." alt="" coords="134,7,265,34"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_sylph_1_1_forward_iterator-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#830cd8edcdc8bdc1957fc6e0c998bc74">construct</a> (bool begin, IteratedObject *obj) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>OVERRIDE THIS METHOD</b> Create the iterator object.  <a href="#830cd8edcdc8bdc1957fc6e0c998bc74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#a19e4359e9be1f29b2df9f33ce63330e">current</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>OVERRIDE THIS METHOD</b> Returns a pointer to the object the iterator is currnetly pointing at.  <a href="#a19e4359e9be1f29b2df9f33ce63330e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#1e96a50cb4f1b48a30d223da5a22755d">next</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>OVERRIDE THIS METHOD</b> Sets the iterator one place forward.  <a href="#1e96a50cb4f1b48a30d223da5a22755d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#96a22f9a85abaaebc02271cfeb6cad76">hasNext</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>OVERRIDE THIS METHOD</b> Tells wheter there are any objects left in the collection.  <a href="#96a22f9a85abaaebc02271cfeb6cad76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#955ffbfa05b991d199fcfaa6b580272f">equals</a> (const <a class="el" href="class_sylph_1_1_forward_iterator.html">ForwardIterator</a>&lt; T, IteratedObject &gt; &amp;other) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>OVERRIDE THIS METHOD</b> Tells wheter this Iterator is equal to any other Iterator over the same type of collection.  <a href="#955ffbfa05b991d199fcfaa6b580272f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#46fcc73707ada486583fc67adcc76a41">copyFrom</a> (<a class="el" href="class_sylph_1_1_forward_iterator.html">ForwardIterator</a>&lt; T, IteratedObject &gt; &amp;other) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><b>OVERRIDE THIS METHOD</b> Copies this iterator's fields from an other <a class="el" href="class_sylph_1_1_forward_iterator.html" title="Facade used to simplify usage of forward iterators.">ForwardIterator</a> over the same type of collection, such that <code>this-&gt;equals(other)</code> is <em>true</em>  <a href="#46fcc73707ada486583fc67adcc76a41"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1646337a927c3e515488d82b5fb4624"></a><!-- doxytag: member="Sylph::ForwardIterator::_end_reached_" ref="a1646337a927c3e515488d82b5fb4624" args="" -->
unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html#a1646337a927c3e515488d82b5fb4624">_end_reached_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do not use or modify! <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, class IteratedObject&gt;<br>
 class Sylph::ForwardIterator&lt; T, IteratedObject &gt;</h3>

Facade used to simplify usage of forward iterators. 
<p>
This class provides several methods to override, which will be used to make a correct implementation of a forward iterator.<p>
Note that this class already correctly implements the difference between a const_iterator and a normal iterator, i.e. a const <a class="el" href="class_sylph_1_1_forward_iterator.html" title="Facade used to simplify usage of forward iterators.">ForwardIterator</a> conforms as a const_iterator, and a non-const <a class="el" href="class_sylph_1_1_forward_iterator.html" title="Facade used to simplify usage of forward iterators.">ForwardIterator</a> conforms as a non-const iterator. Therefore, when implementing this class, make sure that you flag any fields that can be changed (such as indices or pointers to the current item) as <code>mutable</code>. <p>
In order for your own types to be correctly identified as a <a class="el" href="class_sylph_1_1_forward_iterator.html" title="Facade used to simplify usage of forward iterators.">ForwardIterator</a>, please use the <code>S_FORWARD_ITERATOR(</code><em>iterator-name, type-name, object-to-iterate-over</em><code>)</code> <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="830cd8edcdc8bdc1957fc6e0c998bc74"></a><!-- doxytag: member="Sylph::ForwardIterator::construct" ref="830cd8edcdc8bdc1957fc6e0c998bc74" args="(bool begin, IteratedObject *obj) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IteratedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_sylph_1_1_forward_iterator.html">Sylph::ForwardIterator</a>&lt; T, IteratedObject &gt;::construct           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratedObject *&nbsp;</td>
          <td class="paramname"> <em>obj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>OVERRIDE THIS METHOD</b> Create the iterator object. 
<p>
A boolean is passed to tell if this iterator pointed to the beginning or the end of the class (such that internal data pointers can be properly set up), and the object this iterator will be iterating over. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td><em>true</em> if this iterator points to the begin of the collection, <em>false</em> if it points to the end. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obj</em>&nbsp;</td><td>The object this iterator will iterate over. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="46fcc73707ada486583fc67adcc76a41"></a><!-- doxytag: member="Sylph::ForwardIterator::copyFrom" ref="46fcc73707ada486583fc67adcc76a41" args="(ForwardIterator&lt; T, IteratedObject &gt; &amp;other) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IteratedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_sylph_1_1_forward_iterator.html">Sylph::ForwardIterator</a>&lt; T, IteratedObject &gt;::copyFrom           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sylph_1_1_forward_iterator.html">ForwardIterator</a>&lt; T, IteratedObject &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>OVERRIDE THIS METHOD</b> Copies this iterator's fields from an other <a class="el" href="class_sylph_1_1_forward_iterator.html" title="Facade used to simplify usage of forward iterators.">ForwardIterator</a> over the same type of collection, such that <code>this-&gt;equals(other)</code> is <em>true</em> 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>An other Iterator to copy the current one from. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a19e4359e9be1f29b2df9f33ce63330e"></a><!-- doxytag: member="Sylph::ForwardIterator::current" ref="a19e4359e9be1f29b2df9f33ce63330e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IteratedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual pointer <a class="el" href="class_sylph_1_1_forward_iterator.html">Sylph::ForwardIterator</a>&lt; T, IteratedObject &gt;::current           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>OVERRIDE THIS METHOD</b> Returns a pointer to the object the iterator is currnetly pointing at. 
<p>
Note that no beyond-the-end checking needs to be done, this is all done automagically for you. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The object this iterator is currently pointing at. </dd></dl>

</div>
</div><p>
<a class="anchor" name="955ffbfa05b991d199fcfaa6b580272f"></a><!-- doxytag: member="Sylph::ForwardIterator::equals" ref="955ffbfa05b991d199fcfaa6b580272f" args="(const ForwardIterator&lt; T, IteratedObject &gt; &amp;other) const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IteratedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_sylph_1_1_forward_iterator.html">Sylph::ForwardIterator</a>&lt; T, IteratedObject &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_forward_iterator.html">ForwardIterator</a>&lt; T, IteratedObject &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>OVERRIDE THIS METHOD</b> Tells wheter this Iterator is equal to any other Iterator over the same type of collection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>An other <a class="el" href="class_sylph_1_1_forward_iterator.html" title="Facade used to simplify usage of forward iterators.">ForwardIterator</a> to compare this one against. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> iff the two iterators are completely equal (i.e. they iteratate over the same collection and currently point to the same object), false otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="96a22f9a85abaaebc02271cfeb6cad76"></a><!-- doxytag: member="Sylph::ForwardIterator::hasNext" ref="96a22f9a85abaaebc02271cfeb6cad76" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IteratedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_sylph_1_1_forward_iterator.html">Sylph::ForwardIterator</a>&lt; T, IteratedObject &gt;::hasNext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>OVERRIDE THIS METHOD</b> Tells wheter there are any objects left in the collection. 
<p>
This method should not take the past-the-end item into account. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> true if there are any next items, <em>false<em> if there are no more items left. </em></em></dd></dl>

</div>
</div><p>
<a class="anchor" name="1e96a50cb4f1b48a30d223da5a22755d"></a><!-- doxytag: member="Sylph::ForwardIterator::next" ref="1e96a50cb4f1b48a30d223da5a22755d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class IteratedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_sylph_1_1_forward_iterator.html">Sylph::ForwardIterator</a>&lt; T, IteratedObject &gt;::next           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>OVERRIDE THIS METHOD</b> Sets the iterator one place forward. 
<p>
Note that no beyond-the-end checking needs to be done, this is all done automagically for you. 
</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
