<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::Array_base&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::Array_base&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="Sylph::Array_base" --><!-- doxytag: inherits="Sylph::Object" --><a class="el" href="class_sylph_1_1_array__base.html" title="Array_base provides a base class for the specialisations of Array.">Array_base</a> provides a base class for the specialisations of <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_array_8h-source.html">Sylph/Core/Array.h</a>&gt;</code>
<p>
Inherits <a class="el" href="class_sylph_1_1_object.html">Sylph::Object</a>.
<p>
<div class="dynheader">
Collaboration diagram for Sylph::Array_base&lt; T &gt;:</div>
<div class="dynsection">
<p><center><img src="class_sylph_1_1_array__base__coll__graph.png" border="0" usemap="#_sylph_1_1_array__base_3_01_t_01_4__coll__map" alt="Collaboration graph"></center>
<map name="_sylph_1_1_array__base_3_01_t_01_4__coll__map">
<area shape="rect" href="class_sylph_1_1_object.html" title="The root of all classes." alt="" coords="52,7,182,34"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="class_sylph_1_1_array__base-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#49faf4a398f6925ef313e086b79de63d">FilterFunction</a> )(const T &amp;, Any &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function that is used for filtering by the <a class="el" href="class_sylph_1_1_array__base.html#091048e5c8dbac212c0b3673105f19f4" title="This will filter the Array according to a FilterFunction.">filter()</a> method.  <a href="#49faf4a398f6925ef313e086b79de63d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_sylph_1_1_sylph_iterator.html">Iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#5d40ad5a3a5cfa389ceccaf538bbeed3">getIterator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">\ * Get an instance of the Iterator for this class.  <a href="#5d40ad5a3a5cfa389ceccaf538bbeed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_sylph_1_1_sylph_iterator.html">MutableIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#b81bc1e841aee825025e01a091d099fa">getMutableIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">\ * Get an instance of the MutableIterator for this class.  <a href="#b81bc1e841aee825025e01a091d099fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_sylph_iterator.html">Iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#5fb93de308fc7b989b26aeafe49b74f2">itr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"> \ * Alias for <a class="el" href="class_sylph_1_1_array__base.html#5d40ad5a3a5cfa389ceccaf538bbeed3" title="\ * Get an instance of the Iterator for this class.">getIterator()</a> \ *.  <a href="#5fb93de308fc7b989b26aeafe49b74f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_sylph_iterator.html">MutableIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#abe400ebd4ec8f44437600053a236642">mitr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"> \ * Alias for <a class="el" href="class_sylph_1_1_array__base.html#b81bc1e841aee825025e01a091d099fa" title="\ * Get an instance of the MutableIterator for this class.">getMutableIterator()</a> \ *.  <a href="#abe400ebd4ec8f44437600053a236642"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#d3aeaedb14cf9e16d89d984dec94f1c8">Array_base</a> (std::size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new array with the given length.  <a href="#d3aeaedb14cf9e16d89d984dec94f1c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#3bd1c3fe7e09a02f65a37305a8a44354">Array_base</a> (const std::initializer_list&lt; T &gt; &amp;il)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an array from an initializer list.  <a href="#3bd1c3fe7e09a02f65a37305a8a44354"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#023355b2922322c88a22cdbbbb8627d7">Array_base</a> (const T array[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an array from a C-style array.  <a href="#023355b2922322c88a22cdbbbb8627d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#3431dd919f30b460e22ce17bc4eb7201">Array_base</a> (const <a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#3431dd919f30b460e22ce17bc4eb7201"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#e1e5d6a7e2f10976ef723f2a2e3ccb43">Array_base</a> (const basic_range&lt; T &gt; &amp;ran)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an array from a range.  <a href="#e1e5d6a7e2f10976ef723f2a2e3ccb43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#ba4bbe4984097bf6b01d1b609908a69c">~Array_base</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ba4bbe4984097bf6b01d1b609908a69c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#25e994e2aa038f81d051b5eeb3f18fbe">carray</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="#25e994e2aa038f81d051b5eeb3f18fbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#e3543239f348f41073145cd268b088df">carray</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="#e3543239f348f41073145cd268b088df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#e7a6c13ecec4a481157642792803be81">copy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of this array.  <a href="#e7a6c13ecec4a481157642792803be81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#091048e5c8dbac212c0b3673105f19f4">filter</a> (<a class="el" href="class_sylph_1_1_array__base.html#49faf4a398f6925ef313e086b79de63d">FilterFunction</a> func, Any &amp;clientData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will filter the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> according to a FilterFunction.  <a href="#091048e5c8dbac212c0b3673105f19f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#83d93f791355c482ffabe7847df268eb">operator=</a> (const <a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the data pointer of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="#83d93f791355c482ffabe7847df268eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#3d34f036dbd0b5c4c00c9bb81cd5c074">operator[]</a> (std::sidx_t idx)  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for accessing the Array's contents.  <a href="#3d34f036dbd0b5c4c00c9bb81cd5c074"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#40145e7fb31875d72db1154fb2b2af85">operator[]</a> (std::sidx_t idx) const   throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the <code>const</code> version of T&amp; operator[] .  <a href="#40145e7fb31875d72db1154fb2b2af85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#308283745b367bf50c03db6b184b48c9">operator[]</a> (const range &amp;ran)  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Slices the array and returns the subarray.  <a href="#308283745b367bf50c03db6b184b48c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#8db59a5223c5c91bc38121f1cee728ac">operator[]</a> (const range &amp;ran) const   throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const-version of <a class="el" href="class_sylph_1_1_array__base.html#308283745b367bf50c03db6b184b48c9" title="Slices the array and returns the subarray.">operator[](const range &amp;)</a> .  <a href="#8db59a5223c5c91bc38121f1cee728ac"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#8ae028dd923ec6db535b98b10234ad5e">fromPointer</a> (std::size_t <a class="el" href="class_sylph_1_1_array__base.html#b1c91dee8cfdaea416e97b4ef1884454">length</a>, T *orig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an Array&lt;T&gt; from a pointer to T and a length.  <a href="#8ae028dd923ec6db535b98b10234ad5e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const int &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array__base.html#b1c91dee8cfdaea416e97b4ef1884454">length</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The length of the array.  <a href="#b1c91dee8cfdaea416e97b4ef1884454"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class Sylph::Array_base&lt; T &gt;</h3>

<a class="el" href="class_sylph_1_1_array__base.html" title="Array_base provides a base class for the specialisations of Array.">Array_base</a> provides a base class for the specialisations of <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
<b>DO NOT USE DIRECTLY!</b> <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="49faf4a398f6925ef313e086b79de63d"></a><!-- doxytag: member="Sylph::Array_base::FilterFunction" ref="49faf4a398f6925ef313e086b79de63d" args=")(const T &amp;, Any &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html#49faf4a398f6925ef313e086b79de63d">FilterFunction</a>)(const T &amp;, Any &amp;)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function that is used for filtering by the <a class="el" href="class_sylph_1_1_array__base.html#091048e5c8dbac212c0b3673105f19f4" title="This will filter the Array according to a FilterFunction.">filter()</a> method. 
<p>
This function takes both an instance of the class this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> contains, and a reference to a reference to any kind of other data that may need to be passed to the FilterFunction. 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d3aeaedb14cf9e16d89d984dec94f1c8"></a><!-- doxytag: member="Sylph::Array_base::Array_base" ref="d3aeaedb14cf9e16d89d984dec94f1c8" args="(std::size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new array with the given length. 
<p>
A new instance of the reference counted data is created, its refcount set to 1. The memory gets zeroed, so it is perfectly safe to compare with 0 to see if a particular entry in the array has been initialized. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the new <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3bd1c3fe7e09a02f65a37305a8a44354"></a><!-- doxytag: member="Sylph::Array_base::Array_base" ref="3bd1c3fe7e09a02f65a37305a8a44354" args="(const std::initializer_list&lt; T &gt; &amp;il)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>           </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>il</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an array from an initializer list. 
<p>
The length is the same as the length of the initializer list. A new instance of the reference counted data is created, its refcount set to 1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>il</em>&nbsp;</td><td>the initializer list </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="023355b2922322c88a22cdbbbb8627d7"></a><!-- doxytag: member="Sylph::Array_base::Array_base" ref="023355b2922322c88a22cdbbbb8627d7" args="(const T array[])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>           </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>array</em>[]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an array from a C-style array. 
<p>
The contents of the array are copied into this array. The original array will not be modified. The length is the same as the length of the C array. A new instance of the reference counted data is created, its refcount set to 1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td>the c-style array </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3431dd919f30b460e22ce17bc4eb7201"></a><!-- doxytag: member="Sylph::Array_base::Array_base" ref="3431dd919f30b460e22ce17bc4eb7201" args="(const Array_base&lt; T &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
As <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> is reference-counted, it will just copy the pointer to the internal reference and increase the counter by 1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>A reference to the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e1e5d6a7e2f10976ef723f2a2e3ccb43"></a><!-- doxytag: member="Sylph::Array_base::Array_base" ref="e1e5d6a7e2f10976ef723f2a2e3ccb43" args="(const basic_range&lt; T &gt; &amp;ran)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>           </td>
          <td>(</td>
          <td class="paramtype">const basic_range&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an array from a range. 
<p>
The following syntax <pre> Array&lt;int&gt;(range(X, Y)); </pre> is just shorthand for <pre>Array&lt;int&gt;(Y-X) arr;
 for(int i = X; i &lt; Y; i++) arr[i]=X+i;</pre> A new shared data pointer gets created. Length is equal to ran.last() - ran.first() . In order for this constructor to be useful, operator&lt; and operator++ need to have meaningful implementations. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>The range describing the contents of the array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba4bbe4984097bf6b01d1b609908a69c"></a><!-- doxytag: member="Sylph::Array_base::~Array_base" ref="ba4bbe4984097bf6b01d1b609908a69c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::~<a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
This will decrease the reference counter by one. If the counter reaches zero, the backing data will be deleted. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e3543239f348f41073145cd268b088df"></a><!-- doxytag: member="Sylph::Array_base::carray" ref="e3543239f348f41073145cd268b088df" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::carray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
The array returned is not a copy of this array, in fact, changes to the returned array are reflected in this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. This version returns a const c-style array and is used when this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> is const. 
</div>
</div><p>
<a class="anchor" name="25e994e2aa038f81d051b5eeb3f18fbe"></a><!-- doxytag: member="Sylph::Array_base::carray" ref="25e994e2aa038f81d051b5eeb3f18fbe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::carray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a c-style array representing the contents of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
The array returned is not a copy of this array, in fact, changes to the returned array are reflected in this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
</div>
</div><p>
<a class="anchor" name="e7a6c13ecec4a481157642792803be81"></a><!-- doxytag: member="Sylph::Array_base::copy" ref="e7a6c13ecec4a481157642792803be81" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a copy of this array. 
<p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> returned from this method is an exact copy of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, such that ar == ar.copy() . The returned <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> is different from the one returned by operator=, as the reference counted data gets copied as well, in other words, both Arrays will have a different, equal instance of the reference counted data. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A new <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> containing the same data as this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="091048e5c8dbac212c0b3673105f19f4"></a><!-- doxytag: member="Sylph::Array_base::filter" ref="091048e5c8dbac212c0b3673105f19f4" args="(FilterFunction func, Any &amp;clientData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sylph_1_1_array__base.html#49faf4a398f6925ef313e086b79de63d">FilterFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any &amp;&nbsp;</td>
          <td class="paramname"> <em>clientData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This will filter the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> according to a FilterFunction. 
<p>
This function returns a new, 'filtered' <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>, which only contains the entries for which the FilterFunction returns true. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>A pointer to the function which is used for filtering </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientData</em>&nbsp;</td><td>Any data to be passed to the FilterFunction </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A new array containing only the filtered data </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ae028dd923ec6db535b98b10234ad5e"></a><!-- doxytag: member="Sylph::Array_base::fromPointer" ref="8ae028dd923ec6db535b98b10234ad5e" args="(std::size_t length, T *orig)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::fromPointer           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>orig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an Array&lt;T&gt; from a pointer to T and a length. 
<p>
The new array will have the length specified in <code>length</code>. The original array will not be modified, the contents are copied. No bounds-checking is done, therefore, use this function at your own responsability! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the original C array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orig</em>&nbsp;</td><td>The original C array, supplied as a pointer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5d40ad5a3a5cfa389ceccaf538bbeed3"></a><!-- doxytag: member="Sylph::Array_base::getIterator" ref="5d40ad5a3a5cfa389ceccaf538bbeed3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sylph_1_1_sylph_iterator.html">Iterator</a> <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::getIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
\ * Get an instance of the Iterator for this class. 
<p>
The iterator returned \ * is not mutable, i.e. it cannot modify the contents of the collection.<p>
\ * Unless mutability is really required, it is recommended to prefer this\ * method, as it does not allow accidential modifications. * <dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="class_sylph_1_1_sylph_iterator.html" title="SylphIterator provides a easier-to-use wrapper around STL iterators.">SylphIterator</a> specific for the class being iterated over. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b81bc1e841aee825025e01a091d099fa"></a><!-- doxytag: member="Sylph::Array_base::getMutableIterator" ref="b81bc1e841aee825025e01a091d099fa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sylph_1_1_sylph_iterator.html">MutableIterator</a> <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::getMutableIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
\ * Get an instance of the MutableIterator for this class. 
<p>
The iterator\ * returned is mutable, i.e. it can modifiy the contents of the collection. * <dl class="return" compact><dt><b>Returns:</b></dt><dd>A mutable <a class="el" href="class_sylph_1_1_sylph_iterator.html" title="SylphIterator provides a easier-to-use wrapper around STL iterators.">SylphIterator</a> for the class being iterated over. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fb93de308fc7b989b26aeafe49b74f2"></a><!-- doxytag: member="Sylph::Array_base::itr" ref="5fb93de308fc7b989b26aeafe49b74f2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_sylph_iterator.html">Iterator</a> <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::itr           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
 \ * Alias for <a class="el" href="class_sylph_1_1_array__base.html#5d40ad5a3a5cfa389ceccaf538bbeed3" title="\ * Get an instance of the Iterator for this class.">getIterator()</a> \ *. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="class_sylph_1_1_sylph_iterator.html" title="SylphIterator provides a easier-to-use wrapper around STL iterators.">SylphIterator</a> specific for the class being iterated over. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abe400ebd4ec8f44437600053a236642"></a><!-- doxytag: member="Sylph::Array_base::mitr" ref="abe400ebd4ec8f44437600053a236642" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_sylph_iterator.html">MutableIterator</a> <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::mitr           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
 \ * Alias for <a class="el" href="class_sylph_1_1_array__base.html#b81bc1e841aee825025e01a091d099fa" title="\ * Get an instance of the MutableIterator for this class.">getMutableIterator()</a> \ *. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A mutable <a class="el" href="class_sylph_1_1_sylph_iterator.html" title="SylphIterator provides a easier-to-use wrapper around STL iterators.">SylphIterator</a> for the class being iterated over. </dd></dl>

</div>
</div><p>
<a class="anchor" name="83d93f791355c482ffabe7847df268eb"></a><!-- doxytag: member="Sylph::Array_base::operator=" ref="83d93f791355c482ffabe7847df268eb" args="(const Array_base&lt; T &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt;T&gt;&amp; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the data pointer of this <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> with the other <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. 
<p>
The refcount for the current data pointer gets decreased by 1, the refcount for the data pointer of the other array gets increased by 1. In case the this Array'soriginal data pointer's refcount reaches zero, the original data will be deleted. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The other array from which to use the data pointer </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8db59a5223c5c91bc38121f1cee728ac"></a><!-- doxytag: member="Sylph::Array_base::operator[]" ref="8db59a5223c5c91bc38121f1cee728ac" args="(const range &amp;ran) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const range &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Const-version of <a class="el" href="class_sylph_1_1_array__base.html#308283745b367bf50c03db6b184b48c9" title="Slices the array and returns the subarray.">operator[](const range &amp;)</a> . 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>The range describing the slice </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if ran.last() &gt; length </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="308283745b367bf50c03db6b184b48c9"></a><!-- doxytag: member="Sylph::Array_base::operator[]" ref="308283745b367bf50c03db6b184b48c9" args="(const range &amp;ran)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array__base.html">Array_base</a>&lt;T&gt; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const range &amp;&nbsp;</td>
          <td class="paramname"> <em>ran</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Slices the array and returns the subarray. 
<p>
E.g. : <pre><a class="el" href="class_sylph_1_1_array.html">Array&lt;String&gt;</a> subarr = myarr[range(5,8)]</pre> <code>subarr</code> now contains the values of <code>myarr</code>[5] to <code>myarr</code>[8] . Please note that the subarray contains a copy of the original. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ran</em>&nbsp;</td><td>The range describing the slice. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if ran.last() &gt; length </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40145e7fb31875d72db1154fb2b2af85"></a><!-- doxytag: member="Sylph::Array_base::operator[]" ref="40145e7fb31875d72db1154fb2b2af85" args="(std::sidx_t idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">std::sidx_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the <code>const</code> version of T&amp; operator[] . 
<p>
Its behaviour is identical to that of c-style const arrays, but throws an exception instead of overflowing or causing segfaults. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>the index in the array from which to return an element </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if <code>idx &gt; length</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3d34f036dbd0b5c4c00c9bb81cd5c074"></a><!-- doxytag: member="Sylph::Array_base::operator[]" ref="3d34f036dbd0b5c4c00c9bb81cd5c074" args="(std::sidx_t idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">std::sidx_t&nbsp;</td>
          <td class="paramname"> <em>idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (<a class="el" href="class_sylph_1_1_exception.html">Exception</a>)<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used for accessing the Array's contents. 
<p>
Its behaviour is identical to that of c-style arrays, but throws an exception instead of overflowing or causing segfaults. <p>
The <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> will assume ownership over any pointers entered in this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>the index in the array from which to return an element </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="class_sylph_1_1_array_exception.html" title="A generic Exception when an error occurs with an Array.">ArrayException</a></em>&nbsp;</td><td>if <code>idx &gt; length</code> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="b1c91dee8cfdaea416e97b4ef1884454"></a><!-- doxytag: member="Sylph::Array_base::length" ref="b1c91dee8cfdaea416e97b4ef1884454" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="class_sylph_1_1_array__base.html">Sylph::Array_base</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array__base.html#b1c91dee8cfdaea416e97b4ef1884454">length</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The length of the array. 
<p>
This variable is 1-based, while the array itself is 0-based, i.e. if length == N the highest entry in this array is N-1. E.g if array.length == 5, then the higest entry is array[4] 
</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
