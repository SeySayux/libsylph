<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph::ArrayIterator&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_sylph.html">Sylph</a>::<a class="el" href="class_sylph_1_1_array_iterator.html">ArrayIterator</a>
  </div>
</div>
<div class="contents">
<h1>Sylph::ArrayIterator&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="Sylph::ArrayIterator" --><!-- doxytag: inherits="Iterator&lt; T &gt;" -->This class provides an <code><a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a></code> for <code><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a></code>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_vector_iterator_8h-source.html">Sylph/Core/VectorIterator.h</a>&gt;</code>
<p>
Inherits <a class="el" href="class_sylph_1_1_iterator.html">Iterator&lt; T &gt;</a>.
<p>

<p>
<a href="class_sylph_1_1_array_iterator-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#aee3e75d95c390a43d90f614ac4442e1">ArrayIterator</a> (<a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;array)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#aee3e75d95c390a43d90f614ac4442e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="700b939011e263405d0155d26a9d39d4"></a><!-- doxytag: member="Sylph::ArrayIterator::~ArrayIterator" ref="700b939011e263405d0155d26a9d39d4" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#700b939011e263405d0155d26a9d39d4">~ArrayIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#88037cc2267d3b8ae185165494acbb18">hasNext</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if this iterator has any more entries.  <a href="#88037cc2267d3b8ae185165494acbb18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#f86382b11987415b82dc2e63fb8bfc0f">next</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next entry in the array and moves this iterator one place forward.  <a href="#f86382b11987415b82dc2e63fb8bfc0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#bc739bcd9ee73ae33cc1fb1cbbd48a10">hasPrevious</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if this iterator has any more entries in backward direction.  <a href="#bc739bcd9ee73ae33cc1fb1cbbd48a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#6ae4b0d90b706b170d2cee669ebb3cf5">previous</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next entry in the backward direction and moves the iterator one place backward.  <a href="#6ae4b0d90b706b170d2cee669ebb3cf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::idx_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#6549581b3199096ad7d80852746b2b61">nextIndex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next index of the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> in the forward direction.  <a href="#6549581b3199096ad7d80852746b2b61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::idx_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#7016b11e9bd15a38561dac69df131aa1">previousIndex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the next index of the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> in the backward direction.  <a href="#7016b11e9bd15a38561dac69df131aa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#5876053651795d6cde244b1745ed0260">front</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> to the place "before" the first item, that is, it gives the pointer in the iterator such a value that hasPrevious returns false.  <a href="#5876053651795d6cde244b1745ed0260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#a79b7997f07100a70abd5be749c4b808">back</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> to the place "after" the last item, that is, it gives the pointer in the iterator such a value that hasNext returns false.  <a href="#a79b7997f07100a70abd5be749c4b808"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#212722702c995a1c5bb112e7d92fc876">set</a> (T &amp;t)  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces the last item returned by <a class="el" href="class_sylph_1_1_array_iterator.html#f86382b11987415b82dc2e63fb8bfc0f" title="Returns the next entry in the array and moves this iterator one place forward.">next()</a> or <a class="el" href="class_sylph_1_1_array_iterator.html#6ae4b0d90b706b170d2cee669ebb3cf5" title="Returns the next entry in the backward direction and moves the iterator one place...">previous()</a> with the given item.  <a href="#212722702c995a1c5bb112e7d92fc876"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#d1fc6f8af3c3a58f1881fa5f4495a4ff">insert</a> (T &amp;t)  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts the given item after the last returned item.  <a href="#d1fc6f8af3c3a58f1881fa5f4495a4ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_iterator.html#e040815f184a16c812bda4ce3a044083">remove</a> ()  throw (Exception)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the last returned item from the collection.  <a href="#e040815f184a16c812bda4ce3a044083"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class Sylph::ArrayIterator&lt; T &gt;</h3>

This class provides an <code><a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a></code> for <code><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a></code>. 
<p>
This iterator is not fail-fast, multithreading is therefore not yet supported! An easier way to create an instance of this iterator that is collection-independant, is to use <code><a class="el" href="class_sylph_1_1_array.html#260a5b521557e4b77db1c656089dbe81" title="Returns an iterator over the elements.">Array::iterator()</a></code>. This iterator does not support modifing the collection while it iterates over it. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="aee3e75d95c390a43d90f614ac4442e1"></a><!-- doxytag: member="Sylph::ArrayIterator::ArrayIterator" ref="aee3e75d95c390a43d90f614ac4442e1" args="(Array&lt; T &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::<a class="el" href="class_sylph_1_1_array_iterator.html">ArrayIterator</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>array</em>&nbsp;</td><td><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> to iterate over. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a79b7997f07100a70abd5be749c4b808"></a><!-- doxytag: member="Sylph::ArrayIterator::back" ref="a79b7997f07100a70abd5be749c4b808" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::back           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> to the place "after" the last item, that is, it gives the pointer in the iterator such a value that hasNext returns false. 
<p>
This method is useful for backward iterating, i.e. <pre><a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> it = coll.getIterator(); // normal 'forward' iterator
 it.back(); // ready for backward iteration </pre> <dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if this <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> cannot iterate forward </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#db83610eb7fda724619b2511503ffbda">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="5876053651795d6cde244b1745ed0260"></a><!-- doxytag: member="Sylph::ArrayIterator::front" ref="5876053651795d6cde244b1745ed0260" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::front           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Moves the <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> to the place "before" the first item, that is, it gives the pointer in the iterator such a value that hasPrevious returns false. 
<p>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if this <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> cannot iterate backward. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#3b10d72a55fe1d136766c0e8d4834338">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="88037cc2267d3b8ae185165494acbb18"></a><!-- doxytag: member="Sylph::ArrayIterator::hasNext" ref="88037cc2267d3b8ae185165494acbb18" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::hasNext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check if this iterator has any more entries. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if this iterator has more entries, false otherwise </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_sylph_1_1_array.html#1581bf7c3f6a391f0f7f19f6e3eda86e" title="The length of the array.">Array::length</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#c79683a1d6ae7f7eb84df30f30fe0a15">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="bc739bcd9ee73ae33cc1fb1cbbd48a10"></a><!-- doxytag: member="Sylph::ArrayIterator::hasPrevious" ref="bc739bcd9ee73ae33cc1fb1cbbd48a10" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::hasPrevious           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if this iterator has any more entries in backward direction. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> if there are more entries, <em>false</em> otherwise. </dd></dl>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if this <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> cannot iterate backward. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#ed47adf9972ad327fc8d163d2a2df36e">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="d1fc6f8af3c3a58f1881fa5f4495a4ff"></a><!-- doxytag: member="Sylph::ArrayIterator::insert" ref="d1fc6f8af3c3a58f1881fa5f4495a4ff" args="(T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (Exception)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts the given item after the last returned item. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The item to insert. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if the collection does not support insertion. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#157920b6b0ca88fc376be5ff24d9427f">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="f86382b11987415b82dc2e63fb8bfc0f"></a><!-- doxytag: member="Sylph::ArrayIterator::next" ref="f86382b11987415b82dc2e63fb8bfc0f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::next           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next entry in the array and moves this iterator one place forward. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ArrayException</em>&nbsp;</td><td>if trying to return an entry outside the bounds of the <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the next entry in the array. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_sylph_1_1_array_iterator.html#88037cc2267d3b8ae185165494acbb18" title="Check if this iterator has any more entries.">ArrayIterator::hasNext</a> <p>
<a class="el" href="class_sylph_1_1_array.html#9976e4486a5e539fc04b39756e67c71e" title="Used for accessing the Array&#39;s contents.">Array::operator[]</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#069c63384a6b61e06487b268c10e466b">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="6549581b3199096ad7d80852746b2b61"></a><!-- doxytag: member="Sylph::ArrayIterator::nextIndex" ref="6549581b3199096ad7d80852746b2b61" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::nextIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next index of the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> in the forward direction. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Exception</em>&nbsp;</td><td>if there are no more entries. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next index in the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> </dd></dl>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if this <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> cannot iterate forward; or if the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> is unordered. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#1e0fdf071780be8a4ebb27cbf4960a50">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="6ae4b0d90b706b170d2cee669ebb3cf5"></a><!-- doxytag: member="Sylph::ArrayIterator::previous" ref="6ae4b0d90b706b170d2cee669ebb3cf5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::previous           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next entry in the backward direction and moves the iterator one place backward. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Exception</em>&nbsp;</td><td>if there are no more entries. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The previous entry </dd></dl>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if this <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> cannot iterate backward. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#2042ee1216d2c9b9f69a8b88271d84d4">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="7016b11e9bd15a38561dac69df131aa1"></a><!-- doxytag: member="Sylph::ArrayIterator::previousIndex" ref="7016b11e9bd15a38561dac69df131aa1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::previousIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next index of the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> in the backward direction. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Exception</em>&nbsp;</td><td>if there are no more entries. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The previous index in the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> </dd></dl>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if this <a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> cannot iterate backward; or if the <a class="el" href="class_sylph_1_1_iterable.html" title="Implementing this interface allows your class to be iterated by an Iterator.">Iterable</a> is unordered. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#1e8a77dbda572d085bd8142e868ecbf5">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="e040815f184a16c812bda4ce3a044083"></a><!-- doxytag: member="Sylph::ArrayIterator::remove" ref="e040815f184a16c812bda4ce3a044083" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::remove           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (Exception)<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the last returned item from the collection. 
<p>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not requried to override this method if the collection does not support removal. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#c83b838b9ce24a86cdd718729ef2133f">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="212722702c995a1c5bb112e7d92fc876"></a><!-- doxytag: member="Sylph::ArrayIterator::set" ref="212722702c995a1c5bb112e7d92fc876" args="(T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_sylph_1_1_array_iterator.html">Sylph::ArrayIterator</a>&lt; T &gt;::set           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (Exception)<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces the last item returned by <a class="el" href="class_sylph_1_1_array_iterator.html#f86382b11987415b82dc2e63fb8bfc0f" title="Returns the next entry in the array and moves this iterator one place forward.">next()</a> or <a class="el" href="class_sylph_1_1_array_iterator.html#6ae4b0d90b706b170d2cee669ebb3cf5" title="Returns the next entry in the backward direction and moves the iterator one place...">previous()</a> with the given item. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The item to replace the last returned item with. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Note:</b></dt><dd>You are not required to override this method if the collection does not support replacing. </dd></dl>

<p>Reimplemented from <a class="el" href="class_sylph_1_1_iterator.html#cf595e9a9d94d66d66ac907c75da6702">Sylph::Iterator&lt; T &gt;</a>.</p>

</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
