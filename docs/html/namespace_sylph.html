<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Sylph Namespace Reference</h1>The <a class="el" href="namespace_sylph.html" title="The Sylph namespace contains everything in LibSylph.">Sylph</a> namespace contains everything in LibSylph.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Any</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Application</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ApplicationSelf</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html">Array</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array.  <a href="class_sylph_1_1_array.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ByteBuffer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_collection.html">Collection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="class_sylph_1_1_collection.html" title="A Collection represents a group of objects, known as its elements.">Collection</a> represents a group of objects, known as its <em>elements</em>.  <a href="class_sylph_1_1_collection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Exception</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Hashable</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashIterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashMap</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashAssn</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashEntry</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashPointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashClctKeys</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashClctValues</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashClctEntries</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_iterable.html">Iterable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementing this interface allows your class to be iterated by an <code><a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a></code>.  <a href="class_sylph_1_1_iterable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_iterator.html">Iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_iterator.html" title="Iterator provides a transparant interface for iterating over collections.">Iterator</a> provides a transparant interface for iterating over collections.  <a href="class_sylph_1_1_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_object.html">Object</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root of all classes.  <a href="class_sylph_1_1_object.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SChar</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Random</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>basic_range</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Deserializer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SerializedObject</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Serializer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Serializer&lt; S_Array &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Serializer&lt; S_Dictionary &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Serializer&lt; S_Singleton &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>String</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Vector&lt; T * &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>InputStream</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>OutputStream</b></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5463507244d682bbe6b3fe516cab5a70"></a><!-- doxytag: member="Sylph::Dictionary" ref="5463507244d682bbe6b3fe516cab5a70" args="" -->
typedef HashMap&lt; String, Any &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Dictionary</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6684ce4d8cd2d529ceff368f1f553a5f"></a><!-- doxytag: member="Sylph::schar" ref="6684ce4d8cd2d529ceff368f1f553a5f" args="" -->
typedef SChar&nbsp;</td><td class="memItemRight" valign="bottom"><b>schar</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7760be4b3f6300e161b0251da8012d01"></a><!-- doxytag: member="Sylph::range" ref="7760be4b3f6300e161b0251da8012d01" args="" -->
typedef basic_range&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82d1ac62900a341dd85546366799f8c7"></a><!-- doxytag: member="Sylph::frange" ref="82d1ac62900a341dd85546366799f8c7" args="" -->
typedef basic_range&lt; float &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>frange</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="256e2abf6befd2d9853b0c1a97caa2b7"></a><!-- doxytag: member="Sylph::drange" ref="256e2abf6befd2d9853b0c1a97caa2b7" args="" -->
typedef basic_range&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>drange</b></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>HashIteratorType</b> { <b>KEYS</b>, 
<b>VALUES</b>, 
<b>ENTRIES</b>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0">GCPlacement</a> { <a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed055c1fefbbd61326b8040063dfc20938a">UseGC</a>, 
<a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed04a096b0a5718f5a6dbb16f75c06714c6">NoGC</a>, 
<a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0a4af9fd92740c6e987fb58d30e8f0e3f">PointerFreeGC</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for LibSylph's garbage collection.  <a href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>SerializerType</b> { <b>S_Array</b>, 
<b>S_Dictionary</b>, 
<b>S_Singleton</b>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4">AppType</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc43d1b5b35d632e26a5784c1503d8bf392">S_APPTYPE_BUNDLE</a>, 
<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4e1a7847227d0ee2febba17e3e4986ae6">S_APPTYPE_FHS</a>, 
<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc443b12990c4a979871590ccbb5ce1f249">S_APPTYPE_MACOS</a>, 
<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4a9161825e0da102c3df69131910396c8">S_APPTYPE_MACOS_FHS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4b4c98be2edbe429e3758f36dac08dc46">S_APPTYPE_WINDOWS</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This enumeration contains the possible Application Types.  <a href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1d4330bb87843d404b430a8b8a4b4af5"></a><!-- doxytag: member="Sylph::any_cast" ref="1d4330bb87843d404b430a8b8a4b4af5" args="(Any &amp;any)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>any_cast</b> (Any &amp;any)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#10c329a0349416d794bedf8f67feb25f">operator==</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the two Arrays on equality.  <a href="#10c329a0349416d794bedf8f67feb25f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#049ea1ef37b015ca0292637e6d2e3ffa">operator&lt;</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the two Arrays.  <a href="#049ea1ef37b015ca0292637e6d2e3ffa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6cec1fd19c6bd64b7ceb7b82e98ef265"></a><!-- doxytag: member="Sylph::operator!=" ref="6cec1fd19c6bd64b7ceb7b82e98ef265" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bb5da7348d4521878948fd98efe3ff63"></a><!-- doxytag: member="Sylph::operator&gt;" ref="bb5da7348d4521878948fd98efe3ff63" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bf334bfdd62eabe1578e57c16009ba75"></a><!-- doxytag: member="Sylph::operator&lt;=" ref="bf334bfdd62eabe1578e57c16009ba75" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6f27247a06de095bc5707e1a5398b4da"></a><!-- doxytag: member="Sylph::operator&gt;=" ref="6f27247a06de095bc5707e1a5398b4da" args="(const T &amp;lhs, const V &amp;rhs)" -->
template&lt;class T , class V &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;lhs, const V &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1daef2fafded5dbf54806ca32a40e536"></a><!-- doxytag: member="Sylph::Equals" ref="1daef2fafded5dbf54806ca32a40e536" args="(T &amp;t1, T &amp;t2)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Equals</b> (T &amp;t1, T &amp;t2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0c0eb1ca438dbe9540e2d717ccedd5b1"></a><!-- doxytag: member="Sylph::Equals&lt; char * &gt;" ref="0c0eb1ca438dbe9540e2d717ccedd5b1" args="(char *&amp;c1, char *&amp;c2)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Equals&lt; char * &gt;</b> (char *&amp;c1, char *&amp;c2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="32c8513ca640d3152571d8c2b5e20999"></a><!-- doxytag: member="Sylph::PointeeEquals" ref="32c8513ca640d3152571d8c2b5e20999" args="(T *t1, T *t2)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>PointeeEquals</b> (T *t1, T *t2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c504a6b57aaf92a39c119310c3563a05"></a><!-- doxytag: member="Sylph::Hash" ref="c504a6b57aaf92a39c119310c3563a05" args="(T &amp;t)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Hash</b> (T &amp;t)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="40e2d9157335c38959030eb880ee6c99"></a><!-- doxytag: member="Sylph::Hash&lt; int &gt;" ref="40e2d9157335c38959030eb880ee6c99" args="(int &amp;i)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Hash&lt; int &gt;</b> (int &amp;i)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="adbec25919e848b77c4816c75433a1ca"></a><!-- doxytag: member="Sylph::Hash&lt; sint &gt;" ref="adbec25919e848b77c4816c75433a1ca" args="(sint &amp;i)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Hash&lt; sint &gt;</b> (sint &amp;i)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3641ec3b5c8f4d17682861323a464273"></a><!-- doxytag: member="Sylph::Hash&lt; Hashable &gt;" ref="3641ec3b5c8f4d17682861323a464273" args="(Hashable &amp;h)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">sint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>Hash&lt; Hashable &gt;</b> (Hashable &amp;h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b491c2b5871a7235fba07a1042978a8"></a><!-- doxytag: member="Sylph::hash_internal" ref="0b491c2b5871a7235fba07a1042978a8" args="(byte *b, std::size_t len)" -->
sint&nbsp;</td><td class="memItemRight" valign="bottom"><b>hash_internal</b> (byte *b, std::size_t len)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="04aecb7cf10770f021b0490da2f7da3c"></a><!-- doxytag: member="Sylph::operator==" ref="04aecb7cf10770f021b0490da2f7da3c" args="(const HashPointer &amp;p, const Value &amp;v)" -->
template&lt;class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const HashPointer &amp;p, const Value &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f5fd5ab74b0a4d2a8a1d76516026c00d"></a><!-- doxytag: member="Sylph::operator!=" ref="f5fd5ab74b0a4d2a8a1d76516026c00d" args="(const HashPointer &amp;p, const Value &amp;v)" -->
template&lt;class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const HashPointer &amp;p, const Value &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1f2083cf884683b512c9055937d85482"></a><!-- doxytag: member="Sylph::primtype" ref="1f2083cf884683b512c9055937d85482" args="(const T &amp;)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype</b> (const T &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6fe18bf99595d1d89f6af1e2a11eee08"></a><!-- doxytag: member="Sylph::primtype&lt; int &gt;" ref="6fe18bf99595d1d89f6af1e2a11eee08" args="(const int &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; int &gt;</b> (const int &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="adc2c00d3bea1ecb26098ac4d1211886"></a><!-- doxytag: member="Sylph::primtype&lt; sint &gt;" ref="adc2c00d3bea1ecb26098ac4d1211886" args="(const sint &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; sint &gt;</b> (const sint &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a77e97c221a7ee5ec4f903fd187150d2"></a><!-- doxytag: member="Sylph::primtype&lt; suint &gt;" ref="a77e97c221a7ee5ec4f903fd187150d2" args="(const suint &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; suint &gt;</b> (const suint &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d3078e267a519ffbcefdeb3a16b4161c"></a><!-- doxytag: member="Sylph::primtype&lt; long &gt;" ref="d3078e267a519ffbcefdeb3a16b4161c" args="(const long &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; long &gt;</b> (const long &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d188405a599cdd9da3422bf4a0799eec"></a><!-- doxytag: member="Sylph::primtype&lt; long long &gt;" ref="d188405a599cdd9da3422bf4a0799eec" args="(const long long &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; long long &gt;</b> (const long long &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="14e9dc82ca81ba210f6ca070e6845c56"></a><!-- doxytag: member="Sylph::primtype&lt; slong &gt;" ref="14e9dc82ca81ba210f6ca070e6845c56" args="(const slong &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; slong &gt;</b> (const slong &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8aab90f8ffa8d6787de7dd87a839128e"></a><!-- doxytag: member="Sylph::primtype&lt; sulong &gt;" ref="8aab90f8ffa8d6787de7dd87a839128e" args="(const slong &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; sulong &gt;</b> (const slong &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ba2b3418a5766dcb39518e376fe70fda"></a><!-- doxytag: member="Sylph::primtype&lt; float &gt;" ref="ba2b3418a5766dcb39518e376fe70fda" args="(const float &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; float &gt;</b> (const float &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="79830591ce846ae98f73c530e91510ec"></a><!-- doxytag: member="Sylph::primtype&lt; bool &gt;" ref="79830591ce846ae98f73c530e91510ec" args="(const bool &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; bool &gt;</b> (const bool &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2ce3507110585792a96b28c3519f6b58"></a><!-- doxytag: member="Sylph::primtype&lt; Array&lt; T &gt; &gt;" ref="2ce3507110585792a96b28c3519f6b58" args="(const Array&lt; T &gt; &amp;)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; Array&lt; T &gt; &gt;</b> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="37a7fcb36473e91a91c0e30de37ce5d5"></a><!-- doxytag: member="Sylph::primtype&lt; String &gt;" ref="37a7fcb36473e91a91c0e30de37ce5d5" args="(const String &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; String &gt;</b> (const String &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="fd53fb624e4f36432ab52e9fad4bda52"></a><!-- doxytag: member="Sylph::primtype&lt; Dictionary &gt;" ref="fd53fb624e4f36432ab52e9fad4bda52" args="(const Dictionary &amp;)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Primitive::Primitive&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>primtype&lt; Dictionary &gt;</b> (const Dictionary &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9273d6409e66f5736a77027d714abbc7"></a><!-- doxytag: member="Sylph::operator==" ref="9273d6409e66f5736a77027d714abbc7" args="(const String lhs, const char *rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd8f6f39296150fbcd794668147e81d0"></a><!-- doxytag: member="Sylph::operator==" ref="dd8f6f39296150fbcd794668147e81d0" args="(const String lhs, const std::string &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1abf60b67beca7cf44c643991c0ef539"></a><!-- doxytag: member="Sylph::operator==" ref="1abf60b67beca7cf44c643991c0ef539" args="(const String lhs, const String rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef8e02a74d45547953d2aa8d0eec2b0f"></a><!-- doxytag: member="Sylph::operator==" ref="ef8e02a74d45547953d2aa8d0eec2b0f" args="(const String lhs, const QString rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const String lhs, const QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67b60095e2a43245ace0c5fa80cb3746"></a><!-- doxytag: member="Sylph::operator&lt;" ref="67b60095e2a43245ace0c5fa80cb3746" args="(const String lhs, const char *rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1be68f62ef912e2d6f4c1f45a431e067"></a><!-- doxytag: member="Sylph::operator&lt;" ref="1be68f62ef912e2d6f4c1f45a431e067" args="(const String lhs, const std::string &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96274dd3bee7ed126370503adfca8dd5"></a><!-- doxytag: member="Sylph::operator&lt;" ref="96274dd3bee7ed126370503adfca8dd5" args="(const String lhs, const String rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="537345f860302d7ce88d9072c246892d"></a><!-- doxytag: member="Sylph::operator&lt;" ref="537345f860302d7ce88d9072c246892d" args="(const String lhs, const QString rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const String lhs, const QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c0663b99f55d2f9e7dc013044aaaf9bf"></a><!-- doxytag: member="Sylph::operator+=" ref="c0663b99f55d2f9e7dc013044aaaf9bf" args="(const String lhs, const char *rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="835702d909338d752ed5565fde15b718"></a><!-- doxytag: member="Sylph::operator+=" ref="835702d909338d752ed5565fde15b718" args="(const String lhs, const std::string &amp;rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1213753b094dda50c1019f584e2e53c7"></a><!-- doxytag: member="Sylph::operator+=" ref="1213753b094dda50c1019f584e2e53c7" args="(const String lhs, const String rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7a8c2fa55646ddf6c6202d7b56170d34"></a><!-- doxytag: member="Sylph::operator+=" ref="7a8c2fa55646ddf6c6202d7b56170d34" args="(const String lhs, const QString rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const String lhs, const QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="838dd3016161c2a179f1e0580677534e"></a><!-- doxytag: member="Sylph::operator+" ref="838dd3016161c2a179f1e0580677534e" args="(const String lhs, const char *rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const char *rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d55a22c9088ebbc2b24a13e92a5ad3d"></a><!-- doxytag: member="Sylph::operator+" ref="8d55a22c9088ebbc2b24a13e92a5ad3d" args="(const String lhs, const std::string &amp;rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const std::string &amp;rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d5bc728bcc49564392dd9c1ddd48c43c"></a><!-- doxytag: member="Sylph::operator+" ref="d5bc728bcc49564392dd9c1ddd48c43c" args="(const String lhs, const String rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="139b257532c8adef5375915766406a52"></a><!-- doxytag: member="Sylph::operator+" ref="139b257532c8adef5375915766406a52" args="(const String lhs, const QString rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const String lhs, const QString rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e58230c46937317595466f1d00fc96d8"></a><!-- doxytag: member="Sylph::operator%" ref="e58230c46937317595466f1d00fc96d8" args="(const String lhs, const String rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator%</b> (const String lhs, const String rhs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5405526791aa552d4bfe8debb2dbf8c6"></a><!-- doxytag: member="Sylph::operator&amp;" ref="5405526791aa552d4bfe8debb2dbf8c6" args="(const String lhs, const String(*rhs)(String))" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (const String lhs, const String(*rhs)(String))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3139337b867ea3e3abd55e23f6a7456f"></a><!-- doxytag: member="Sylph::operator*" ref="3139337b867ea3e3abd55e23f6a7456f" args="(const String lhs, const std::size_t len)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const String lhs, const std::size_t len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7afc598c49a48938da591434b594502b"></a><!-- doxytag: member="Sylph::tr" ref="7afc598c49a48938da591434b594502b" args="(String rhs)" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>tr</b> (String rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1ec18919e78c6a90a20fb893f0f216b9"></a><!-- doxytag: member="Sylph::carraycopy" ref="1ec18919e78c6a90a20fb893f0f216b9" args="(T src[], std::size_t srcPos, T dest[], std::size_t destPos, std::size_t length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>carraycopy</b> (T src[], std::size_t srcPos, T dest[], std::size_t destPos, std::size_t length)  throw (Exception)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="79fa1efc44df30e50560d78d2e6dbbad"></a><!-- doxytag: member="Sylph::arraycopy" ref="79fa1efc44df30e50560d78d2e6dbbad" args="(Array&lt; T &gt; &amp;src, std::size_t srcPos, Array&lt; T &gt; dest, std::size_t destPos, std::size_t length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>arraycopy</b> (<a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;src, std::size_t srcPos, <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; dest, std::size_t destPos, std::size_t length)  throw (Exception)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4ba09af53e2961fd5d8e8b9d00fb3e71"></a><!-- doxytag: member="Sylph::carraysize" ref="4ba09af53e2961fd5d8e8b9d00fb3e71" args="(T(&amp;)[N])" -->
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>carraysize</b> (T(&amp;)[N])</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7ab9c150491a2abed4f1a8db088468f3"></a><!-- doxytag: member="Sylph::arraycopy" ref="7ab9c150491a2abed4f1a8db088468f3" args="(const Array&lt; T &gt; &amp;src, std::size_t srcPos, Array&lt; T &gt; &amp;dest, std::size_t destPos, std::size_t length)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>arraycopy</b> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;src, std::size_t srcPos, <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;dest, std::size_t destPos, std::size_t length)  throw (Exception)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#95deda9702779e11c906740388e9ce9c">newgc</a> (T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new (non-LibSylph) object using the LibSylph garbage collection.  <a href="#95deda9702779e11c906740388e9ce9c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e464ead89d804d13a804319c1e8e3da"></a><!-- doxytag: member="Sylph::byte" ref="2e464ead89d804d13a804319c1e8e3da" args="" -->
typedef&nbsp;</td><td class="memItemRight" valign="bottom"><b>byte</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="namespace_sylph.html" title="The Sylph namespace contains everything in LibSylph.">Sylph</a> namespace contains everything in LibSylph. 
<p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4"></a><!-- doxytag: member="Sylph::AppType" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4">Sylph::AppType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This enumeration contains the possible Application Types. 
<p>
Each element is backed by an implementation of <code>ApplicationSelf</code> in <code>Sylph::OS</code>.<p>
When you want to use an alternative implementation of <code>ApplicationSelf</code>, you can pass one of the elements of this enumeration as the definition of the macro <code>APP_TYPE</code> to the compiler, e.g. for GCC: <pre>g++ -o myapp -lSCore -DAPPTYPE=S_APPTYPE_FHS myapp.cpp</pre> Note that this usage is not checked, i.e. with this command you can compile perfectly on Mac OS X or Windows, but <code>S_APPTYPE_FHS</code> only works on Linux, but this error will not be reported. Therefore using this kind of override requires support for a dynamic configuration system, such as <em>GNU Autotools</em> or <em>CMake</em> <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc43d1b5b35d632e26a5784c1503d8bf392"></a><!-- doxytag: member="S_APPTYPE_BUNDLE" ref="8e3a8cf0fd1c1cf417e7834d2a473dc43d1b5b35d632e26a5784c1503d8bf392" args="" -->S_APPTYPE_BUNDLE</em>&nbsp;</td><td>
This AppType uses a LibSylph-style 'bundle' structure. 
<p>
For more information about LibSylph bundles, please see <code>LinuxBundleAppSelf</code> or the wiki. This is the default AppType on Linux</td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4e1a7847227d0ee2febba17e3e4986ae6"></a><!-- doxytag: member="S_APPTYPE_FHS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4e1a7847227d0ee2febba17e3e4986ae6" args="" -->S_APPTYPE_FHS</em>&nbsp;</td><td>
This AppType uses a classic 'FHS'-like structure on Linux. 
<p>
The application automatically detects its prefix. See <code>LinuxFHSAppSelf</code> for more info. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc443b12990c4a979871590ccbb5ce1f249"></a><!-- doxytag: member="S_APPTYPE_MACOS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc443b12990c4a979871590ccbb5ce1f249" args="" -->S_APPTYPE_MACOS</em>&nbsp;</td><td>
This is the default AppType on Mac OS X. 
<p>
It uses Mac OS X-like bundles. It's not up to us to document that, right? Just ask Apple. See <code>MacOSAppSelf</code> </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4a9161825e0da102c3df69131910396c8"></a><!-- doxytag: member="S_APPTYPE_MACOS_FHS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4a9161825e0da102c3df69131910396c8" args="" -->S_APPTYPE_MACOS_FHS</em>&nbsp;</td><td>
AppType on Mac OS X that works similar to <code>S_APPTYPE_FHS</code> . 
<p>
See <code>MacOSFHSAppSelf</code>. (Yes, that <b>are</b> 6 capitals. Yes, you <b>can</b> use CapsLock. No, you won't ever have to type this -- it's all done internally) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4b4c98be2edbe429e3758f36dac08dc46"></a><!-- doxytag: member="S_APPTYPE_WINDOWS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4b4c98be2edbe429e3758f36dac08dc46" args="" -->S_APPTYPE_WINDOWS</em>&nbsp;</td><td>
Default AppType on Windows. 
<p>
See <code>WindowsAppSelf</code> . I keep asking myself why whe have this, as LibSylph won't even compile on Windows... </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="392e3435758ffcbf741d6637f4695ed0"></a><!-- doxytag: member="Sylph::GCPlacement" ref="392e3435758ffcbf741d6637f4695ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0">Sylph::GCPlacement</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used for LibSylph's garbage collection. 
<p>
It is passed as a parameter to new, e.g. <pre>
 Array&lt;int&gt;; = new (NoGC) Array&lt;int&gt;(5); // create a length-5 array without GC
 </pre> This is most often used for creating LibSylph-objects not managed by the garbage collector. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="392e3435758ffcbf741d6637f4695ed055c1fefbbd61326b8040063dfc20938a"></a><!-- doxytag: member="UseGC" ref="392e3435758ffcbf741d6637f4695ed055c1fefbbd61326b8040063dfc20938a" args="" -->UseGC</em>&nbsp;</td><td>
Use the garbage collector; this is the default. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="392e3435758ffcbf741d6637f4695ed04a096b0a5718f5a6dbb16f75c06714c6"></a><!-- doxytag: member="NoGC" ref="392e3435758ffcbf741d6637f4695ed04a096b0a5718f5a6dbb16f75c06714c6" args="" -->NoGC</em>&nbsp;</td><td>
Do not use the garbage collector for this specific object. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="392e3435758ffcbf741d6637f4695ed0a4af9fd92740c6e987fb58d30e8f0e3f"></a><!-- doxytag: member="PointerFreeGC" ref="392e3435758ffcbf741d6637f4695ed0a4af9fd92740c6e987fb58d30e8f0e3f" args="" -->PointerFreeGC</em>&nbsp;</td><td>
When the object you create does not contain pointers, use this to speed up GC -- however, this is usually not useful, as most LibSylph containers contain pointers. 
<p>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="95deda9702779e11c906740388e9ce9c"></a><!-- doxytag: member="Sylph::newgc" ref="95deda9702779e11c906740388e9ce9c" args="(T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * Sylph::newgc           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new (non-LibSylph) object using the LibSylph garbage collection. 
<p>
Example (using Qt): <pre>
 QPushButton but * = newgc(QPushButton("Hello"));
 </pre> The syntax is very similar to that of the normal new operator. 
</div>
</div><p>
<a class="anchor" name="049ea1ef37b015ca0292637e6d2e3ffa"></a><!-- doxytag: member="Sylph::operator&lt;" ref="049ea1ef37b015ca0292637e6d2e3ffa" args="(const Array&lt; T &gt; &amp;lhs, const Array&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sylph::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the two Arrays. 
<p>
To Arrays compare less than when their lengths are identical and each of the items compare less than to the item on the same position in the other array. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> when the first array compares less than the first, <em>false</em> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="10c329a0349416d794bedf8f67feb25f"></a><!-- doxytag: member="Sylph::operator==" ref="10c329a0349416d794bedf8f67feb25f" args="(const Array&lt; T &gt; &amp;lhs, const Array&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sylph::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the two Arrays on equality. 
<p>
To Arrays compare equal when their lengths are identical and each of the items compare equal to the item on the same position in the other array. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> when the two arrays compare equal, <em>false</em> otherwise. </dd></dl>

</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.5.8</small></address>
</body>
</html>
