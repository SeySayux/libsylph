<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibSylph: Sylph Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Sylph Namespace Reference</h1>The <a class="el" href="namespace_sylph.html" title="The Sylph namespace contains everything in LibSylph.">Sylph</a> namespace contains everything in LibSylph.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_any.html">Any</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class for any kind of class.  <a href="class_sylph_1_1_any.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_application.html">Application</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing an application.  <a href="class_sylph_1_1_application.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_application_self.html">ApplicationSelf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="class_sylph_1_1_application.html" title="Class representing an application.">Application</a> representing the currently running application.  <a href="class_sylph_1_1_application_self.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array.html">Array</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a> provides a safe array.  <a href="class_sylph_1_1_array.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_bool_convertible__base.html">BoolConvertible_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for <a class="el" href="class_sylph_1_1_bool_convertible.html" title="Implementation of the Safe Bool Idiom.">BoolConvertible</a>.  <a href="class_sylph_1_1_bool_convertible__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_bool_convertible.html">BoolConvertible</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the Safe Bool Idiom.  <a href="class_sylph_1_1_bool_convertible.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_collection.html">Collection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="class_sylph_1_1_collection.html" title="A Collection represents a group of objects, known as its elements.">Collection</a> represents a group of objects, known as its <em>elements</em>.  <a href="class_sylph_1_1_collection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_exception.html">Exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides a ready-to-use interface for exception handling.  <a href="class_sylph_1_1_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_array_exception.html">ArrayException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic <a class="el" href="class_sylph_1_1_exception.html" title="This class provides a ready-to-use interface for exception handling.">Exception</a> when an error occurs with an <a class="el" href="class_sylph_1_1_array.html" title="Array provides a safe array.">Array</a>.  <a href="class_sylph_1_1_array_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_file_exception.html">FileException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A genreric <a class="el" href="class_sylph_1_1_exception.html" title="This class provides a ready-to-use interface for exception handling.">Exception</a> which gets thrown whenever something goes wrong in the File class.  <a href="class_sylph_1_1_file_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_i_o_exception.html">IOException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a generic exception for I/O errors.  <a href="class_sylph_1_1_i_o_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_illegal_argument_exception.html">IllegalArgumentException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic exception to flag an argument with an illegal state was passed to an function or method.  <a href="class_sylph_1_1_illegal_argument_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_illegal_state_exception.html">IllegalStateException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic exception to flag that a method is not supported in the current state of the object it is invoked on.  <a href="class_sylph_1_1_illegal_state_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_null_pointer_exception.html">NullPointerException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This <a class="el" href="class_sylph_1_1_exception.html" title="This class provides a ready-to-use interface for exception handling.">Exception</a> gets thrown when a pointer to <code>NULL</code> is passed to a function or method.  <a href="class_sylph_1_1_null_pointer_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_serialization_exception.html">SerializationException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This <a class="el" href="class_sylph_1_1_exception.html" title="This class provides a ready-to-use interface for exception handling.">Exception</a> gets thrown if there is a problem with serializing or deserializing an object.  <a href="class_sylph_1_1_serialization_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_hashable.html">Hashable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to indicate this object provides its own <code>hashCode</code> function.  <a href="class_sylph_1_1_hashable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_forward_iterator.html">ForwardIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Facade used to simplify usage of forward iterators.  <a href="class_sylph_1_1_forward_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_sylph_iterator.html">SylphIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_sylph_1_1_sylph_iterator.html" title="SylphIterator provides a easier-to-use wrapper around STL iterators.">SylphIterator</a> provides a easier-to-use wrapper around STL iterators.  <a href="class_sylph_1_1_sylph_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_object.html">Object</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root of all classes.  <a href="class_sylph_1_1_object.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sylph_1_1_string.html">String</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="class_sylph_1_1_string.html" title="The String class represents character strings.">String</a> class represents character strings.  <a href="class_sylph_1_1_string.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef HashMap&lt; <a class="el" href="class_sylph_1_1_string.html">String</a>, <a class="el" href="class_sylph_1_1_any.html">Any</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#0c7b0200d7ae06e1607829fc737e1c9a">Dictionary</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Dictionary is a HashMap that maps Strings to Anys.  <a href="#0c7b0200d7ae06e1607829fc737e1c9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12380d58a638ec489736d7b60963a34c"></a><!-- doxytag: member="Sylph::uchar" ref="12380d58a638ec489736d7b60963a34c" args="" -->
typedef std::uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#12380d58a638ec489736d7b60963a34c">uchar</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A integral type for storing an UTF-16 character. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4">AppType</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc43d1b5b35d632e26a5784c1503d8bf392">S_APPTYPE_BUNDLE</a>, 
<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4e1a7847227d0ee2febba17e3e4986ae6">S_APPTYPE_FHS</a>, 
<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc443b12990c4a979871590ccbb5ce1f249">S_APPTYPE_MACOS</a>, 
<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4a9161825e0da102c3df69131910396c8">S_APPTYPE_MACOS_FHS</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4b4c98be2edbe429e3758f36dac08dc46">S_APPTYPE_WINDOWS</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This enumeration contains the possible Application Types.  <a href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0">GCPlacement</a> { <a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed055c1fefbbd61326b8040063dfc20938a">UseGC</a>, 
<a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed04a096b0a5718f5a6dbb16f75c06714c6">NoGC</a>, 
<a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0a4af9fd92740c6e987fb58d30e8f0e3f">PointerFreeGC</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for LibSylph's garbage collection.  <a href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#1d4330bb87843d404b430a8b8a4b4af5">any_cast</a> (<a class="el" href="class_sylph_1_1_any.html">Any</a> &amp;any)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cast an <a class="el" href="class_sylph_1_1_any.html" title="Wrapper class for any kind of class.">Any</a> to the type it is holding.  <a href="#1d4330bb87843d404b430a8b8a4b4af5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#10c329a0349416d794bedf8f67feb25f">operator==</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the two Arrays on equality.  <a href="#10c329a0349416d794bedf8f67feb25f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#049ea1ef37b015ca0292637e6d2e3ffa">operator&lt;</a> (const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; T &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares the two Arrays.  <a href="#049ea1ef37b015ca0292637e6d2e3ffa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#7be2729c2252c04c807bed8da37a6d78">operator==</a> (const <a class="el" href="class_sylph_1_1_bool_convertible.html">BoolConvertible</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_bool_convertible.html">BoolConvertible</a>&lt; U &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Short circuits the <code>operator==</code> for BoolConvertibles.  <a href="#7be2729c2252c04c807bed8da37a6d78"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#e0e899a2df3d9094e6692b2cdebde679">operator!=</a> (const <a class="el" href="class_sylph_1_1_bool_convertible.html">BoolConvertible</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_sylph_1_1_bool_convertible.html">BoolConvertible</a>&lt; U &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Short circuits the <code>operator!=</code> for BoolConvertibles.  <a href="#e0e899a2df3d9094e6692b2cdebde679"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#63ddec6709f9855d2db98dc3ff22179b">newgc</a> (const Args &amp;...args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new (non-LibSylph) object using the LibSylph garbage collection.  <a href="#63ddec6709f9855d2db98dc3ff22179b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#bbcdc8958d6c7815a8bbb4e322a0eef7">deletegc</a> (const T *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a (non-LibSylph) object that was previously allocated with LibSylph <code><a class="el" href="namespace_sylph.html#63ddec6709f9855d2db98dc3ff22179b" title="Creates a new (non-LibSylph) object using the LibSylph garbage collection.">newgc()</a></code>.  <a href="#bbcdc8958d6c7815a8bbb4e322a0eef7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_sylph_1_1_array.html">Array</a>&lt; <a class="el" href="namespace_sylph.html#12380d58a638ec489736d7b60963a34c">uchar</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sylph.html#5aa3c7bde7827380a2a4012e43b1e901">spacechars</a> = {' ', '\n', '\r', '\f', '\t', '\013'}</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This array contains the characters that are considered to be whitespace characters by default.  <a href="#5aa3c7bde7827380a2a4012e43b1e901"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="namespace_sylph.html" title="The Sylph namespace contains everything in LibSylph.">Sylph</a> namespace contains everything in LibSylph. 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="0c7b0200d7ae06e1607829fc737e1c9a"></a><!-- doxytag: member="Sylph::Dictionary" ref="0c7b0200d7ae06e1607829fc737e1c9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HashMap&lt;<a class="el" href="class_sylph_1_1_string.html">String</a>, <a class="el" href="class_sylph_1_1_any.html">Any</a>&gt; <a class="el" href="namespace_sylph.html#0c7b0200d7ae06e1607829fc737e1c9a">Sylph::Dictionary</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A Dictionary is a HashMap that maps Strings to Anys. 
<p>
This typedef is provided because this is the most commonly used instance of a HashMap -- that is, <a class="el" href="class_sylph_1_1_string.html" title="The String class represents character strings.">String</a> to T with <a class="el" href="class_sylph_1_1_any.html" title="Wrapper class for any kind of class.">Any</a> a generic wrapper for any T. It is provided solely for convenience and currently does not have any special properties above a HashMap. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4"></a><!-- doxytag: member="Sylph::AppType" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_sylph.html#8e3a8cf0fd1c1cf417e7834d2a473dc4">Sylph::AppType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This enumeration contains the possible <a class="el" href="class_sylph_1_1_application.html" title="Class representing an application.">Application</a> Types. 
<p>
Each element is backed by an implementation of <code><a class="el" href="class_sylph_1_1_application_self.html" title="An Application representing the currently running application.">ApplicationSelf</a></code> in <code>Sylph::OS</code>.<p>
When you want to use an alternative implementation of <code><a class="el" href="class_sylph_1_1_application_self.html" title="An Application representing the currently running application.">ApplicationSelf</a></code>, you can pass one of the elements of this enumeration as the definition of the macro <code>APP_TYPE</code> to the compiler, e.g. for GCC: <pre>g++ -o myapp -lSylph -DAPPTYPE=S_APPTYPE_FHS myapp.cpp</pre> Note that this usage is not checked, i.e. with this command you can compile perfectly on Mac OS X or Windows, but <code>S_APPTYPE_FHS</code> only works on Linux, but this error will not be reported. Therefore using this kind of override requires support for a dynamic configuration system, such as <em>GNU Autotools</em> or <em>CMake</em> <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc43d1b5b35d632e26a5784c1503d8bf392"></a><!-- doxytag: member="S_APPTYPE_BUNDLE" ref="8e3a8cf0fd1c1cf417e7834d2a473dc43d1b5b35d632e26a5784c1503d8bf392" args="" -->S_APPTYPE_BUNDLE</em>&nbsp;</td><td>
This AppType uses a LibSylph-style 'bundle' structure. 
<p>
For more information about LibSylph bundles, please see <code>LinuxBundleAppSelf</code> or the wiki. This is the default AppType on Linux</td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4e1a7847227d0ee2febba17e3e4986ae6"></a><!-- doxytag: member="S_APPTYPE_FHS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4e1a7847227d0ee2febba17e3e4986ae6" args="" -->S_APPTYPE_FHS</em>&nbsp;</td><td>
This AppType uses a classic 'FHS'-like structure on Linux. 
<p>
The application automatically detects its prefix. See <code>LinuxFHSAppSelf</code> for more info. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc443b12990c4a979871590ccbb5ce1f249"></a><!-- doxytag: member="S_APPTYPE_MACOS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc443b12990c4a979871590ccbb5ce1f249" args="" -->S_APPTYPE_MACOS</em>&nbsp;</td><td>
This is the default AppType on Mac OS X. 
<p>
It uses Mac OS X-like bundles. It's not up to us to document that, right? Just ask Apple. See <code>MacOSAppSelf</code> </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4a9161825e0da102c3df69131910396c8"></a><!-- doxytag: member="S_APPTYPE_MACOS_FHS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4a9161825e0da102c3df69131910396c8" args="" -->S_APPTYPE_MACOS_FHS</em>&nbsp;</td><td>
AppType on Mac OS X that works similar to <code>S_APPTYPE_FHS</code> . 
<p>
See <code>MacOSFHSAppSelf</code>. (Yes, that <b>are</b> 6 capitals. Yes, you <b>can</b> use CapsLock. No, you won't ever have to type this -- it's all done internally) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="8e3a8cf0fd1c1cf417e7834d2a473dc4b4c98be2edbe429e3758f36dac08dc46"></a><!-- doxytag: member="S_APPTYPE_WINDOWS" ref="8e3a8cf0fd1c1cf417e7834d2a473dc4b4c98be2edbe429e3758f36dac08dc46" args="" -->S_APPTYPE_WINDOWS</em>&nbsp;</td><td>
Default AppType on Windows. 
<p>
See <code>WindowsAppSelf</code> . I keep asking myself why whe have this, as LibSylph won't even compile on Windows... </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="392e3435758ffcbf741d6637f4695ed0"></a><!-- doxytag: member="Sylph::GCPlacement" ref="392e3435758ffcbf741d6637f4695ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_sylph.html#392e3435758ffcbf741d6637f4695ed0">Sylph::GCPlacement</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used for LibSylph's garbage collection. 
<p>
It is passed as a parameter to new, e.g. <pre>
 Array&lt;int&gt;; = new (NoGC) Array&lt;int&gt;(5); // create a length-5 array without GC
 </pre> This is most often used for creating LibSylph-objects not managed by the garbage collector. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="392e3435758ffcbf741d6637f4695ed055c1fefbbd61326b8040063dfc20938a"></a><!-- doxytag: member="UseGC" ref="392e3435758ffcbf741d6637f4695ed055c1fefbbd61326b8040063dfc20938a" args="" -->UseGC</em>&nbsp;</td><td>
Use the garbage collector; this is the default. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="392e3435758ffcbf741d6637f4695ed04a096b0a5718f5a6dbb16f75c06714c6"></a><!-- doxytag: member="NoGC" ref="392e3435758ffcbf741d6637f4695ed04a096b0a5718f5a6dbb16f75c06714c6" args="" -->NoGC</em>&nbsp;</td><td>
Do not use the garbage collector for this specific object. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="392e3435758ffcbf741d6637f4695ed0a4af9fd92740c6e987fb58d30e8f0e3f"></a><!-- doxytag: member="PointerFreeGC" ref="392e3435758ffcbf741d6637f4695ed0a4af9fd92740c6e987fb58d30e8f0e3f" args="" -->PointerFreeGC</em>&nbsp;</td><td>
When the object you create does not contain pointers, use this to speed up GC -- however, this is usually not useful, as most LibSylph containers contain pointers. 
<p>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="1d4330bb87843d404b430a8b8a4b4af5"></a><!-- doxytag: member="Sylph::any_cast" ref="1d4330bb87843d404b430a8b8a4b4af5" args="(Any &amp;any)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* Sylph::any_cast           </td>
          <td>(</td>
          <td class="paramtype">Any &amp;&nbsp;</td>
          <td class="paramname"> <em>any</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cast an <a class="el" href="class_sylph_1_1_any.html" title="Wrapper class for any kind of class.">Any</a> to the type it is holding. 
<p>
This cast is completely safe, and either returns a correct pointer, or completely fails. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>any</em>&nbsp;</td><td>An <a class="el" href="class_sylph_1_1_any.html" title="Wrapper class for any kind of class.">Any</a> to convert to an instance of the type it is representing </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the internal data of the <a class="el" href="class_sylph_1_1_any.html" title="Wrapper class for any kind of class.">Any</a> if the conversion was successful, <code>NULL</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbcdc8958d6c7815a8bbb4e322a0eef7"></a><!-- doxytag: member="Sylph::deletegc" ref="bbcdc8958d6c7815a8bbb4e322a0eef7" args="(const T *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sylph::deletegc           </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes a (non-LibSylph) object that was previously allocated with LibSylph <code><a class="el" href="namespace_sylph.html#63ddec6709f9855d2db98dc3ff22179b" title="Creates a new (non-LibSylph) object using the LibSylph garbage collection.">newgc()</a></code>. 
<p>
Altough explicit deletion is not required when using garbage collection, the function is provided anyways for your convenience. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>pointer to a class previously allocated with <code>newgc</code> </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>T</em> none </dd></dl>

</div>
</div><p>
<a class="anchor" name="63ddec6709f9855d2db98dc3ff22179b"></a><!-- doxytag: member="Sylph::newgc" ref="63ddec6709f9855d2db98dc3ff22179b" args="(const Args &amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * Sylph::newgc           </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new (non-LibSylph) object using the LibSylph garbage collection. 
<p>
Example (using Qt): <pre>
 QPushButton * but = newgc&lt;QPushButton&gt;("Hello");
 </pre> The syntax is very similar to that of the normal new operator. <dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>T</em> Constructible with <em>Args</em> </dd></dl>
<dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>Args</em> none </dd></dl>

</div>
</div><p>
<a class="anchor" name="e0e899a2df3d9094e6692b2cdebde679"></a><!-- doxytag: member="Sylph::operator!=" ref="e0e899a2df3d9094e6692b2cdebde679" args="(const BoolConvertible&lt; T &gt; &amp;lhs, const BoolConvertible&lt; U &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sylph::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const BoolConvertible&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoolConvertible&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Short circuits the <code>operator!=</code> for BoolConvertibles. 
<p>
You are ought to implement your own <code>operator!=</code> for a <a class="el" href="class_sylph_1_1_bool_convertible.html" title="Implementation of the Safe Bool Idiom.">BoolConvertible</a> derived class. 
</div>
</div><p>
<a class="anchor" name="049ea1ef37b015ca0292637e6d2e3ffa"></a><!-- doxytag: member="Sylph::operator&lt;" ref="049ea1ef37b015ca0292637e6d2e3ffa" args="(const Array&lt; T &gt; &amp;lhs, const Array&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sylph::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the two Arrays. 
<p>
To Arrays compare less than when their lengths are identical and each of the items compare less than to the item on the same position in the other array. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> when the first array compares less than the first, <em>false</em> otherwise. </dd></dl>
<dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>T</em> LessThanComparable </dd></dl>

</div>
</div><p>
<a class="anchor" name="7be2729c2252c04c807bed8da37a6d78"></a><!-- doxytag: member="Sylph::operator==" ref="7be2729c2252c04c807bed8da37a6d78" args="(const BoolConvertible&lt; T &gt; &amp;lhs, const BoolConvertible&lt; U &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sylph::operator==           </td>
          <td>(</td>
          <td class="paramtype">const BoolConvertible&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoolConvertible&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Short circuits the <code>operator==</code> for BoolConvertibles. 
<p>
You are ought to implement your own <code>operator==</code> for a <a class="el" href="class_sylph_1_1_bool_convertible.html" title="Implementation of the Safe Bool Idiom.">BoolConvertible</a> derived class. 
</div>
</div><p>
<a class="anchor" name="10c329a0349416d794bedf8f67feb25f"></a><!-- doxytag: member="Sylph::operator==" ref="10c329a0349416d794bedf8f67feb25f" args="(const Array&lt; T &gt; &amp;lhs, const Array&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sylph::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares the two Arrays on equality. 
<p>
To Arrays compare equal when their lengths are identical and each of the items compare equal to the item on the same position in the other array. <dl class="return" compact><dt><b>Returns:</b></dt><dd><em>true</em> when the two arrays compare equal, <em>false</em> otherwise. </dd></dl>
<dl class="user" compact><dt><b>Template requirements:</b></dt><dd><em>T</em> EqualityComparable </dd></dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="5aa3c7bde7827380a2a4012e43b1e901"></a><!-- doxytag: member="Sylph::spacechars" ref="5aa3c7bde7827380a2a4012e43b1e901" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sylph_1_1_array.html">Array</a>&lt;<a class="el" href="namespace_sylph.html#12380d58a638ec489736d7b60963a34c">uchar</a>&gt; <a class="el" href="namespace_sylph.html#5aa3c7bde7827380a2a4012e43b1e901">Sylph::spacechars</a> = {' ', '\n', '\r', '\f', '\t', '\013'}<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This array contains the characters that are considered to be whitespace characters by default. 
<p>
The following shows the contents of this list: <ul>
<li>
space (Unicode U+0020, character literal ' ')  </li>
<li>
newline (Unicode U+000A, character literal '<br>
') </li>
<li>
carriage return (Unicode U+000D, character literal '') </li>
<li>
form feed (Unicode U+000C, character literal '') </li>
<li>
horizontal tab (Unicode U+0009, character literal '') </li>
<li>
vertical tab (Unicode U+000B, character literal '' or '') </li>
</ul>
<p>
Certain functions, such as <a class="el" href="class_sylph_1_1_string.html#5a0bedc4563e052c7094b4848c552d4f" title="Removes all whitespace characters on the front and on the end of the String.">String::trim()</a> and String::split() use this array to determine a default set of characters to look after. 
</div>
</div><p>
</div>
<hr size="1" class="unhidden"><address style="text-align: right;"><small>
Documentation for LibSylph by Doxygen
</body>
</html>
